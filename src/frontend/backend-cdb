#!/usr/bin/perl -w

use Getopt::Long;
use Pod::Usage;
use Data::Dumper;

use lib "/home/aleks/pro/udb/lib";
use BrownCS::UDB;

my $udb = BrownCS::UDB->new;

my $PNAME = 'cdb';
my $PVERS = '2.0';
my $VERSION  = "cdb version $PVERS\n";
my $USAGE  = "Client Database (CDB)\n\n";

# Default pathnames

my $PATH_CFFILE = '/tstaff/share/cdb/config.pl';
my $PATH_MKFILE = '/tstaff/share/cdb/.cdb_make.state';

my $SCP = '/usr/bin/scp';
my $SSH = '/usr/bin/ssh';

# Miscellaneous constants

my $DEF_DELIM = "\t";
my $MAXHOSTNAMELEN = 256;
my $MK_MODTIME = 0;
my $MK_BLDTIME = 1;
my $ADMINHOST = "adminhost";

# Declare hash of maps we build from the database and their subroutines

my %g_cdb_maps = (
  'ethers' => \&build_ethers,                   # Construct /etc/ethers NIS map
  'bootparams' => \&build_bootparams,           # Construct /etc/bootparams NIS map
  'netgroup' => \&build_netgroup,               # Construct /etc/netgroup NIS map
  'tftpboot' => \&build_tftpboot,               # Construct /tftpboot directory
  'dhcp' => \&build_dhcp,                       # Construct dhcpd.conf directory
  'dns' => \&build_dns,                         # Construct named data files
  'nagios-hosts' => \&build_nagios_hosts,       # Construct nagios hosts.cfg file
  'nagios-services' => \&build_nagios_services, # Construct nagios services.cfg file
  'wpkg-hosts' => \&build_wpkg_hosts,           # Construct wpkg hosts.xml file
);

# Declare hash tables of include keys for extra error checking

my %g_cdb_include_ethers = ();
my %g_cdb_include_ip_addrs = ();
my %g_cdb_include_hosts = ();

# Declare array of temporary files, to be deleted upon exit
my @g_tmpfiles = ();

#
# FUNCTION: get_date
#    DESCR: Return current date using nice format
#

sub get_date {
  my(@elems);
  my($raw);

  chop($raw = ctime(time));
  @elems = split(/\s+/, $raw);
  return $elems[2] . $elems[1] . substr($elems[4], -2);
}

#
# FUNCTION: fmt_time
#    DESCR: Return specified time using nice format
#

sub fmt_time {
  my($time) = @_;
  my($sec, $min, $hour, $mday, $mon, $year) = localtime($time);

  my(@moname) = ( 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec' );

  return "${mday}${moname[$mon]}${year} ${hour}:${min}:${sec}";
}

#
# FUNCTION: init_make_state
#    DESCR: Initialize a new make state hash and return a reference to it.
#           The hash consists of the names of maps, and a reference to an
#           array of two elements containing the last modification time of
#           the map's data, and the last build time of the map.
#

sub init_make_state {
  my($states) = {};
  warn "$PNAME: WARNING: All maps will be rebuilt at next make\n";
  foreach $map (keys(%g_cdb_maps)) { $states->{$map} = [ 0, 0 ]; }
  return $states;
}

#
# FUNCTION: load_make_state
#    DESCR: Load the cdb make state file, creating a new one if necessary.
#           You should only load the make state file once you have established
#           a write-lock on the database, since we don't do any locking here.
#

sub load_make_state {
  my($file) = @_;
  my($states) = {};
  my(@tokens);

  if(open(MKSTATE, "<$file")) {
    while(<MKSTATE>) {
      next if(/^\s*$/ || /^\s*#/);      # Skip blank lines and comments
      chop($_);                         # Remove newline
      @tokens = split(/:/, $_);         # Split line into tokens

      # Each line must contain exactly three tokens

      if(scalar(@tokens) != 3) {
        warn "$PNAME: WARNING: Invalid number of tokens on line $. of $file\n";
        $states = init_make_state();
        last;
      }

      # First token must be a valid map name

      if(!defined($g_cdb_maps{$tokens[0]})) {
        warn "$PNAME: WARNING: Bad map \"$tokens[0]\" on line $. of $file\n";
        $states = init_make_state();
        last;
      }

      # Each map may only have a single state line in the file

      if(defined($states->{$tokens[0]})) {
        warn "$PNAME: WARNING: \"$tokens[0]\" redefined on line $. of $file\n";
        $states = init_make_state();
        last;
      }

      # Remaining two tokens should be numbers

      if($tokens[1] !~ /^\d+$/ || $tokens[2] !~ /^\d+$/) {
        warn "$PNAME: WARNING: Invalid time on line $. of $file\n";
        $states = init_make_state();
        last;
      }

      $states->{$tokens[0]} = [ $tokens[1], $tokens[2] ];
    }

    close(MKSTATE);

    # Verify that all maps have been defined in the state file

    foreach $map (keys(%g_cdb_maps)) {
      unless(defined($states->{$map})) {
        warn "$PNAME: WARNING: Map \"$map\" not defined in $file\n";
        $states = init_make_state();
        last;
      }
    }
  
  } else {
    warn "$PNAME: WARNING: Cannot open $file: $!\n";
    $states = init_make_state();
  }

  return $states;
}

#
# FUNCTION: write_make_state
#    DESCR: Write out new make state file from states hash.  This function
#           should always be called _after_ write_db so that the state file
#           has a more recent modification time than the database file.
#

sub write_make_state {
  my($states, $file) = @_;

  open(MKSTATE, ">$file") || die "$PNAME: Failed to rewrite $file: $!\n";

  print MKSTATE "#\n#  FILE: $file\n";
  print MKSTATE "# DESCR: Cdb make state file -- DO NOT EDIT THIS FILE!\n#\n";

  foreach $map (keys(%$states)) {
    print MKSTATE $map, ':', $states->{$map}->[0], ':',
      $states->{$map}->[1], "\n";
  }

  close(MKSTATE);
  chmod($CDB_DBF_PERMS, $file);
  chown($>, (getgrnam($CDB_DBF_GROUP))[2], $file);
}

#
# FUNCTION: touch_make_state
#    DESCR: Update modification time on a make state hash entry.
#

sub touch_make_state {
  my($states, $map) = @_;
  $states->{$map}->[$MK_MODTIME] = time();
}

#
# FUNCTION: update_make_state
#    DESCR: Update the build time on a make state hash entry.
#

sub update_make_state {
  my($states, $map) = @_;
  $states->{$map}->[$MK_BLDTIME] = time();
}

#
# FUNCTION: sighandler
#    DESCR: Clean up and quit if we receive a signal
#

sub sighandler {
  print "\n*** Termination signal received\n";
  $udb->finish;
  foreach (@g_tmpfiles) {
    unlink($_);
  }
  exit(0);
}

#
# FUNCTION: END
#    DESCR: Exit handler to clean things up in case we die.
#

END {
  foreach (@g_tmpfiles) {
    unlink($_);
  }
}

#
# FUNCTION: parse_ethernet_includes
#    DESCR: Build hash of ethernet address keys from include file for ethers
#           NIS map.
#

sub parse_ethernet_includes {
  my($include) = $cdb_map_includes{'ethers'};
  my($line);

  return if(!defined($cdb_map_includes{'ethers'}) || ! -f("$include"));

  open(ETHERS, "<$include") ||
    die "$PNAME: ERROR: Failed to open $include: $!\n";

  while(<ETHERS>) {
    ($line = $_) =~ s/#.*//;
    next if($line =~ /^\s*$/);
    
    if($line !~ /^\s*([a-fA-F0-9:]+)\s+(\w+)\s*$/) {
      warn "$PNAME: WARNING: \"$include\", line ${.}: Invalid ethers syntax\n";
      next;
    }

    $g_cdb_include_ethers{$1} = $2;
  }

  close(ETHERS);
}

#
# FUNCTION: parse_host_includes
#    DESCR: Build hash of host names, aliases, and IP addresses from include
#           file for NIS hosts map.
#

sub parse_host_includes {
  my($include) = $cdb_map_includes{'hosts'};
  my($line);

  return if(!defined($cdb_map_includes{'hosts'}) || ! -f ("$include"));

  open(HOSTS, "<$include") ||
    die "$PNAME: ERROR: Failed to open $include: $!\n";

  while(<HOSTS>) {
    ($line = $_) =~ s/#.*//;
    next if($line =~ /^\s*$/);

    if($line !~ /^\s*([0-9\.]+)\s+(\S.+)$/) {
      warn "$PNAME: WARNING: \"$include\", line ${.}: Invalid hosts syntax\n";
      next;
    }

    foreach $name (split(/\s+/, $2)) {
      $g_cdb_include_ip_addrs{$1} = $2
        if(!defined($g_cdb_include_ip_addrs{$1}));
      $g_cdb_include_hosts{$name} = $1;
    }
  }

  close(HOSTS);
}

#
# FUNCTION: build_tftpboot
#    DESCR: Rebuild the tftp network boot directory
#

sub build_tftpboot {
  foreach $host (sort(keys(%$cdb_by_hostname))) {

    my $primgrp = $cdb_by_hostname->{$host}{'prim_grp'};
    next unless($cdb_primary_groups{$primgrp} & $NG_TFTP);

    my @ipaddr = split(/\./, $cdb_by_hostname->{$host}{'ip_addr'});

    my $ostype = $cdb_by_hostname->{$host}{'os_type'};

    my $arch = $cdb_by_hostname->{$host}{'hw_arch'};

    # Do not generate tftpboot information if your os_type does not define
    # all required fields.  Can be used for placeholders.

    my $tftpboot_path = $cdb_os_types->{$ostype}{'tftpboot_path'};
    if(!defined($tftpboot_path)) {
      next;
    }

    my $bootimage = $cdb_by_hostname->{$host}{'pxelink'} || $cdb_os_types->{$ostype}{'images'}{$arch};
    if(!defined($bootimage)) {
      next;
    }

    my $hex_ip = sprintf("$tftpboot_path/%0.2X%0.2X%0.2X%0.2X",
      $ipaddr[0], $ipaddr[1], $ipaddr[2], $ipaddr[3]);

    if(!$opt_X) {
      unlink("$tftpboot_path/$hex_ip");
      symlink("$bootimage", "$tftpboot_path/$hex_ip") ||
        warn "$PNAME: ERROR: Failed to create link $hex_ip: $!\n";
    } else {
      print "DEBUG: $host $hex_ip\n";
    }
  }
}

#
# FUNCTION: build_bootparams
#    DESCR: Build a new /var/yp/src/bootparams NIS src map.
#

sub build_bootparams {
  my($file, $include) = @_;
  my($ostype, $subnet, $arch, $primgrp);
  my($boot_server, $netboot_path, $boot_path, $js_server, $js_path);
  my(@inctext);

  $PATH_TMPFILE = $file . '.tmp';

  open(BOOTP, ">$PATH_TMPFILE") ||
    die "$PNAME: ERROR: Failed to open $PATH_TMPFILE: $!\n";

  print BOOTP "#\n#  FILE: $file\n",
    "# DESCR: NIS bootparams map generated by $PNAME version $PVERS\n",
    "#  DATE: ", get_date(), "\n#\n\n";

  if(-s ("$include")) {
    open(INCLUDE, "<$include") ||
      die "$PNAME: ERROR: Failed to open include $include: $!\n";

    @inctext = <INCLUDE>;
    print BOOTP @inctext;
    close(INCLUDE);
  }

  foreach $host (sort(keys(%$cdb_by_hostname))) {
    $primgrp = $cdb_by_hostname->{$host}{'prim_grp'};
    next unless($cdb_primary_groups{$primgrp} & $NG_BOOTP);

    $subnet = (split(/\./, $cdb_by_hostname->{$host}{'ip_addr'}))[2];
    $ostype = $cdb_by_hostname->{$host}{'os_type'};
    $arch = $cdb_by_hostname->{$host}{'hw_arch'};

    if(!defined($cdb_os_types->{$ostype})) {
      warn "$PNAME: WARNING: No OS type specifier for $host, $ostype\n";
      next;
    }

    # Do not generate bootparams information if your os_type does not define
    # all required JumpStart fields.  Can be used for placeholders.

    if(!defined($cdb_os_types->{$ostype}{'netboot_path'}) ||
       !defined($cdb_os_types->{$ostype}{'install_path'}) ||
       !defined($cdb_os_types->{$ostype}{'jumpstart_path'}) ||
       !defined($cdb_os_types->{$ostype}{'cache_path'})) {
      next;
    }

    $netboot_path = $cdb_os_types->{$ostype}{'netboot_path'};

    ($boot_server, $boot_path) =
      split(/:/, $cdb_os_types->{$ostype}{'install_path'});

    ($js_server, $js_path) =
      split(/:/, $cdb_os_types->{$ostype}{'jumpstart_path'});

    print BOOTP $host,
      ' root=', $boot_server, $subnet, ':', $boot_path, '/', $netboot_path,
      ' install=', $boot_server, $subnet, ':', $boot_path,
      ' boottype=', $CDB_BOOT_TYPE,
      ' install_config=', $js_server, ':', $js_path,
      ' sysid_config=', $js_server, ':', $js_path, "\n\n";
  }

  print BOOTP "# EOF\n";
  close(BOOTP);

  die "$PNAME: ERROR: Failed to rename $file: $!\n"
    if(!rename("$PATH_TMPFILE", "$file"));
}

sub add_to_group {
  my ($netgroups, $grp, $host) = @_;

  if(defined($netgroups->{$grp})) {
    $netgroups->{$grp} .= " (${host},,)";
  } else {
    $netgroups->{$grp} = "(${host},,)";
  }

}

#
# FUNCTION: build_netgroup
#    DESCR: Generate a new /var/yp/src/netgroup file from the database
#

sub build_netgroup {
  my($file, $include) = @_;
  my(%netgroups) = ();
  my($primgrp, $line, $length, $gridx, $grsubname, $grsubidx);
  my(@grmem, @grsub, @inctext);

  $PATH_TMPFILE = $file . '.tmp';

  open(NETGROUP, ">$PATH_TMPFILE") ||
    die "$PNAME: ERROR: Failed to open $PATH_TMPFILE: $!\n";

  print NETGROUP "#\n#  FILE: $file\n",
    "# DESCR: NIS netgroup map generated by $PNAME version $PVERS\n",
    "#  DATE: ", get_date(), "\n#\n\n";

  if(-s ("$include")) {
    open(INCLUDE, "<$include") ||
      die "$PNAME: ERROR: Failed to open include $include: $!\n";

    @inctext = <INCLUDE>;
    print NETGROUP @inctext;
    close(INCLUDE);
  }

  foreach $host (keys(%$cdb_by_hostname)) {
    $primgrp = $cdb_by_hostname->{$host}{'prim_grp'};
    next unless($cdb_primary_groups{$primgrp} & $NG_NETGR);

    add_to_group(\%netgroups, $primgrp, $host);

    foreach $class (split(/,/, $cdb_by_hostname->{$host}{'classes'})) {
      if ($class =~ /^camera$/) {
        add_to_group(\%netgroups, "camera", $host);
      } elsif ($class =~ /^cgc$/) {
        add_to_group(\%netgroups, "cgc", $host);
      } elsif ($class =~ /^graphics$/) {
        add_to_group(\%netgroups, "graphics", $host);
      } elsif ($class =~ /^fun$/) {
        add_to_group(\%netgroups, "ugrad", $host);
      } elsif ($class =~ /^ssh\.forward$/) {
        add_to_group(\%netgroups, "sunlab", $host);
      } elsif ($class =~ /^tstaff-netgroup$/) {
        add_to_group(\%netgroups, "tstaff", $host);
      } elsif ($class =~ /^thermo$/) {
        add_to_group(\%netgroups, "thermo", $host);
      } elsif ($class =~ /^liebert$/) {
        add_to_group(\%netgroups, "liebert", $host);
      } elsif ($class =~ /^server$/) {
        add_to_group(\%netgroups, "server", $host);
      }
    }
  }

  # Annoying hack: ndbm limits us to 1024-byte datum.  Decompose groups
  # of greater than 32 elements into subgroups as a workaround.
  
  $gridx = 0;

  foreach $grp (keys(%netgroups)) {
    @grmem = split(/ /, $netgroups{$grp});

    if(scalar(@grmem) > 32) {
      delete $netgroups{$grp};
      $netgroups{$grp} = '';
      $grsubidx = 0;

      while(scalar(@grmem) > 0) {
        @grsub = splice(@grmem, 0, (scalar(@grmem)>32) ? 32 : scalar(@grmem));
        $grsubname = "0-" . $gridx . "-" . $grsubidx++;
        $netgroups{$grsubname} = join(' ', @grsub);

        if($netgroups{$grp} ne '') {
          $netgroups{$grp} .= " $grsubname";
        } else {
          $netgroups{$grp} = $grsubname;
        }
      }

      $gridx++;
    }
  }

  # End of ndbm hack

  foreach $grp (sort(keys(%netgroups))) {
    print NETGROUP "# Netgroup $grp\n\n";
    $line = "$grp\t";

    @grmem = split(/ /, $netgroups{$grp});
    foreach $i (0 .. $#grmem) {
      if((length($line) + length($grmem[$i]) + 11) < 80) {
        $line .= $grmem[$i] . ' ';
      } else {
        print NETGROUP $line, ($i < $#grmem) ? "\\\n" : '';
        $line = $grmem[$i] . ' ';
      }
    }

    print NETGROUP $line, "\n\n";
  }

  print NETGROUP "\n# EOF\n";
  close(NETGROUP);

  die "$PNAME: ERROR: Failed to rename $file: $!\n" if(!rename("$PATH_TMPFILE", "$file"));
  foreach $dir (@CDB_NETGROUP_DIRS) {
    system("cp -p $file $dir/netgroup");
    if ( $? != 0 ) {
      warn "$PNAME: ERROR: Failed to copy netgroup file to $dir\n";
    }
  }

}

#
# FUNCTION: build_ethers
#    DESCR: Generate a new /var/yp/src/ethers file from the database
#

sub build_ethers {
  my($file, $include) = @_;
  my(@hosts) = keys(%$cdb_by_hostname);
  my(@inctext, $primgrp, $ethernet);

  @g_sort_order = ( 'ethernet' ); 
  @hosts = sort sort_hostnames @hosts;

  $PATH_TMPFILE = $file . '.tmp';

  open(ETHERS, ">$PATH_TMPFILE") ||
    die "$PNAME: ERROR: Failed to open $PATH_TMPFILE: $!\n";

  print ETHERS "#\n#  FILE: $file\n",
    "# DESCR: NIS ethers map generated by $PNAME version $PVERS\n",
    "#  DATE: ", get_date(), "\n#\n\n";

  if(-s ("$include")) {
    open(INCLUDE, "<$include") ||
      die "$PNAME: ERROR: Failed to open include $include: $!\n";

    @inctext = <INCLUDE>;
    print ETHERS @inctext;
    close(INCLUDE);
  }

  foreach $host (@hosts) {
    $primgrp = $cdb_by_hostname->{$host}{'prim_grp'};
    $ethernet = $cdb_by_hostname->{$host}{'ethernet'};
    next unless $ethernet;
    $tabs = (length($ethernet) > 15) ? "\t" : "\t\t";
    print ETHERS "${ethernet}${tabs}${host}\n"
      if($cdb_primary_groups{$primgrp} & $NG_ETHERS);
  }

  print ETHERS "\n# EOF\n";
  close(ETHERS);

  die "$PNAME: ERROR: Failed to rename $file: $!\n"
    if(!rename("$PATH_TMPFILE", "$file"));
}

#
# FUNCTION: build_dhcp
#    DESCR: Generate a new dhcpd file from the database
#

sub build_dhcp {
    my($file, $include) = @_;
    my(@all_hosts) = keys(%$cdb_by_hostname);
    my(@inctext, @pxe_hosts, @ppc_pxe_hosts, @dynamic_hosts, @other_hosts);
    my($primgrp, $ethernet, $status);

    @g_sort_order = ( 'ethernet' ); 
    @all_hosts = sort sort_hostnames @all_hosts;

    foreach $host (@all_hosts) {
      # make sure only hosts with ethernet address are entered into the
      # DHCP tables
      next unless ($cdb_by_hostname->{$host}{'ethernet'});

      $prim_grp = $cdb_by_hostname->{$host}{'prim_grp'};
      $arch = $cdb_by_hostname->{$host}{'hw_arch'};
      if($prim_grp eq "linux" || $prim_grp eq "ilab" || \
         $prim_grp eq "private" || $prim_grp eq "standalone" ) {
        if ($arch eq "ppc") {
          push @ppc_pxe_hosts, $host;
        } else {
          push @pxe_hosts, $host;
        }
      } elsif($prim_grp eq "dynamic") {
        push @dynamic_hosts, $host;
      } else {
        push @other_hosts, $host;
      }
    }
    
    $PATH_TMPFILE = $file . '.tmp';

    open(DHCP, ">$PATH_TMPFILE") ||
      die "$PNAME: ERROR: Failed to open $PATH_TMPFILE: $!\n";

    print DHCP "#\n#  FILE: $file\n",
    "# DESCR: DHCP config generated by $PNAME version $PVERS\n",
    "#  DATE: ", get_date(), "\n#\n\n";

    if(-s ("$include")) {
        open(INCLUDE, "<$include") ||
          die "$PNAME: ERROR: Failed to open include $include: $!\n";

        @inctext = <INCLUDE>;
        print DHCP @inctext;
        close(INCLUDE);
    }

    print DHCP "#\n";
    print DHCP "# PXElinux Clients\n";
    print DHCP "#\n";

    print DHCP "group {\n";
    print DHCP "    use-host-decl-names on;\n";
    print DHCP "    next-server pxe.cs.brown.edu;\n";
    print DHCP "    filename \"pxelinux.0\"\;\n\n";
    foreach $host (@pxe_hosts) {
        $ethernet = $cdb_by_hostname->{$host}{'ethernet'};
        next unless ( $ethernet );

        # only include hosts that are listed as active or monitored
        $status = $cdb_by_hostname->{$host}{'status'};
        next unless ( $status eq "active" || $status eq "monitored" || $status eq "ugrad-monitored" );

        print DHCP "    host $host {\n";
        print DHCP "        hardware ethernet $ethernet;\n";
        print DHCP "        fixed-address $host;\n";
        print DHCP "    }\n";
    }
    print DHCP "}\n\n";

    print DHCP "#\n";
    print DHCP "# PPC yaboot Clients\n";
    print DHCP "#\n";

    print DHCP "group {\n";
    print DHCP "    use-host-decl-names on;\n";
    print DHCP "    next-server pxe.cs.brown.edu;\n";
    print DHCP "    filename \"yaboot\"\;\n\n";
    foreach $host (@ppc_pxe_hosts) {
        $ethernet = $cdb_by_hostname->{$host}{'ethernet'};
        next unless ( $ethernet );

        # only include hosts that are listed as active or monitored
        $status = $cdb_by_hostname->{$host}{'status'};
        next unless ( $status eq "active" || $status eq "monitored" || $status eq "ugrad-monitored" );

        print DHCP "    host $host {\n";
        print DHCP "        hardware ethernet $ethernet;\n";
        print DHCP "        fixed-address $host;\n";
        print DHCP "    }\n";
    }
    print DHCP "}\n\n";

    print DHCP "#\n";
    print DHCP "# Other Static DHCP Clients\n";
    print DHCP "#\n";

    print DHCP "group {\n";
    print DHCP "    use-host-decl-names on;\n";
    foreach $host (@other_hosts) {
        $ethernet = $cdb_by_hostname->{$host}{'ethernet'};
        next unless ( $ethernet );

        # only include hosts that are listed as active or monitored
        $status = $cdb_by_hostname->{$host}{'status'};
        next unless ( $status eq "active" || $status eq "monitored" || $status eq "ugrad-monitored" );

        print DHCP "    host $host {\n";
        print DHCP "        hardware ethernet $ethernet;\n";
        print DHCP "        fixed-address $host;\n";
        print DHCP "    }\n";
    }
    print DHCP "}\n\n";

    print DHCP "#\n";
    print DHCP "# DHCP Clients\n";
    print DHCP "#\n";

    print DHCP "group {\n";
    print DHCP "    use-host-decl-names on;\n";
    foreach $host (@dynamic_hosts) {
        $ethernet = $cdb_by_hostname->{$host}{'ethernet'};
        next unless ( $ethernet );

        # only include hosts that are listed as active
        $status = $cdb_by_hostname->{$host}{'status'};
        next unless ( $status eq "active" );

        print DHCP "    # $cdb_by_hostname->{$host}{'comment'}\n";
        print DHCP "    host $host {\n";
        print DHCP "        hardware ethernet $ethernet;\n";
        print DHCP "    }\n";
    }
    print DHCP "}\n";

    print DHCP "\n# EOF\n";
    close(DHCP);
    
    die "$PNAME: ERROR: Failed to rename $file: $!\n"
      if(!rename("$PATH_TMPFILE", "$file"));

    # send new config file to each server
    foreach $host (@CDB_DHCP_SERVERS) {
      system($SCP, '-pq', $file, "$host:/etc");
      if ( $? != 0 ) {
        warn "$PNAME: ERROR: Failed to copy DNS files to $host\n";
      }
    }

    system($SSH, '-x', 'dhcp', '/etc/init.d/dhcp restart');
}

# 
# FUNCTION: build_nagios_hosts
#    DESCR: Generate the nagios hosts.cfg file
#

sub build_nagios_hosts {
  my($file, $include) = @_;
  my(@hosts) = keys(%$cdb_by_hostname);
  my(@inctext, $primgrp, $aliases, $tabs, $hostref);

  @g_sort_order = ( 'ip_addr' ); 
  @hosts = sort sort_hostnames @hosts;

  $PATH_TMPFILE = $file . '.tmp';

  open(OUT, ">$PATH_TMPFILE") ||
    die "$PNAME: ERROR: Failed to open $PATH_TMPFILE: $!\n";

  print OUT "#\n#  FILE: $file\n",
    "# DESCR: nagios hosts.cfg generated by $PNAME version $PVERS\n",
    "#  DATE: ", get_date(), "\n#\n";

  if(-s ("$include")) {
    open(INCLUDE, "<$include") ||
      die "$PNAME: ERROR: Failed to open include $include: $!\n";

    @inctext = <INCLUDE>;
    print OUT @inctext;
    close(INCLUDE);
  }

  foreach $host (@hosts) {
    $hostref = $cdb_by_hostname->{$host};
    $prim_grp = $hostref->{'prim_grp'};
    $ip_addr = $hostref->{'ip_addr'};

    next unless($cdb_primary_groups{$prim_grp} & $NG_NAGIOS);

    if ( $hostref->{'status'} eq "monitored" ) {
      print OUT "define host{\n";
      print OUT "\tuse\t\t\thost_template\n";
      print OUT "\thost_name\t\t$host\n";
      print OUT "\taddress\t\t\t$ip_addr\n";
      print OUT "}\n\n";
    } elsif ( $hostref->{'status'} eq "ugrad-monitored" ) {
      print OUT "define host{\n";
      print OUT "\tuse\t\t\tugrad_template\n";
      print OUT "\thost_name\t\t$host\n";
      print OUT "\taddress\t\t\t$ip_addr\n";
      print OUT "}\n\n";    
    }

  }

  print OUT "# EOF\n";
  close(OUT);

  die "$PNAME: ERROR: Failed to rename $file: $!\n"
    if(!rename("$PATH_TMPFILE", "$file"));

  # send new config file to each server
  system($SCP, '-pq', $file, "storm:/etc/nagios3/conf.d/");
  if ( $? != 0 ) {
    warn "$PNAME: ERROR: Failed to copy nagios files to $host\n";
  }

  system($SSH, '-x', 'storm', '/etc/init.d/nagios3 restart');

}

# 
# FUNCTION: build_nagios_services
#    DESCR: Generate the nagios services.cfg file
#

sub build_nagios_services {
  my($file, $include) = @_;
  my(@hosts) = keys(%$cdb_by_hostname);
  my(@inctext, $primgrp, $aliases, $tabs, $hostref);

  @g_sort_order = ( 'ip_addr' ); 
  @hosts = sort sort_hostnames @hosts;

  $PATH_TMPFILE = $file . '.tmp';

  open(OUT, ">$PATH_TMPFILE") ||
    die "$PNAME: ERROR: Failed to open $PATH_TMPFILE: $!\n";

  print OUT "#\n#  FILE: $file\n",
    "# DESCR: nagios services.cfg generated by $PNAME version $PVERS\n",
    "#  DATE: ", get_date(), "\n#\n";

  if(-s ("$include")) {
    open(INCLUDE, "<$include") ||
      die "$PNAME: ERROR: Failed to open include $include: $!\n";

    @inctext = <INCLUDE>;
    print OUT @inctext;
    close(INCLUDE);
  }

  foreach $host (@hosts) {
    $hostref = $cdb_by_hostname->{$host};
    $prim_grp = $hostref->{'prim_grp'};
    $ip_addr = $hostref->{'ip_addr'};

    next unless($cdb_primary_groups{$prim_grp} & $NG_NAGIOS);

    next unless ( $hostref->{'status'} eq "monitored" );

    print OUT "define service{\n";
    print OUT "\tuse\t\t\tping_template\n";
    print OUT "\thost_name\t\t$host\n";
    print OUT "}\n\n";    

    my @classes = split(/,/, $hostref->{'classes'});

    for (@classes) {

      if (/printer/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tprinter_template\n";
        print OUT "\thost_name\t\t$host\n";
        print OUT "}\n\n";    

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tqueuing_template\n";
        print OUT "\thost_name\t\t$host\n";
        print OUT "\tcheck_command\t\tcheck-queuing!$host\n";
        print OUT "}\n\n";

      } elsif (/smtp/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tsmtp_template\n";
        print OUT "\thost_name\t\t$host\n";
        print OUT "}\n\n";    

      } elsif (/ftp/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tftp_template\n";
        print OUT "\thost_name\t\t$host\n";
        print OUT "}\n\n";    

      } elsif (/http/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\thttp_template\n";
        print OUT "\thost_name\t\t$host\n";
        print OUT "}\n\n";    

      } elsif (/imap/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\timap_template\n";
        print OUT "\thost_name\t\t$host\n";
        print OUT "}\n\n";    

      } elsif (/pop/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tpop_template\n";
        print OUT "\thost_name\t\t$host\n";
        print OUT "}\n\n";    

      } elsif (/dns/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tdns_template\n";
        print OUT "\thost_name\t\t$host\n";
        print OUT "}\n\n";

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tdns_internal_template\n";
        print OUT "\thost_name\t\t$host\n";
        print OUT "}\n\n";    

      } elsif (/dhcp/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tdhcp_template\n";
        print OUT "\thost_name\t\t$host\n";
        print OUT "}\n\n";

      } elsif (/telnet/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\ttelnet_template\n";
        print OUT "\thost_name\t\t$host\n";
        print OUT "}\n\n";

      } elsif (/liebert/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tliebert_template\n";
        print OUT "\thost_name\t\t$host\n";
        print OUT "\tcontact_groups\t\tspoc_group,tstaff_group\n";
        print OUT "}\n\n";

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tliebert_alarms_template\n";
        print OUT "\thost_name\t\t$host\n";
        print OUT "\tcontact_groups\t\tspoc_group,tstaff_group\n";
        print OUT "}\n\n";

      } elsif (/thermo/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tthermo_template\n";
        print OUT "\thost_name\t\t$host\n";
        print OUT "\tcontact_groups\t\temergency_group,spoc_group,tstaff_group\n";
        print OUT "}\n\n";

      } elsif (/pgsql/|/postgresql\.db/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tpgsql_template\n";
        print OUT "\thost_name\t\t$host\n";
        print OUT "}\n\n";

      } elsif (/netapp/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tnetapp_template\n";
        print OUT "\thost_name\t\t$host\n";
        print OUT "}\n\n";

      } elsif (/ntp/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tntp_template\n";
        print OUT "\thost_name\t\t$host\n";
        print OUT "}\n\n";

      } elsif (/ssh/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tssh_template\n";
        print OUT "\thost_name\t\t$host\n";
        print OUT "}\n\n";

      } elsif (/mailman/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tmailman_template\n";
        print OUT "\thost_name\t\t$host\n";
        print OUT "}\n\n";

      } elsif (/spamassassin/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tspamd_template\n";
        print OUT "\thost_name\t\t$host\n";
        print OUT "}\n\n";

        print OUT "define service{\n";
        print OUT "\tuse\t\t\typbind_template\n";
        print OUT "\thost_name\t\t$host\n";
        print OUT "}\n\n";   

      } elsif (/sge/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tsge_template\n";
        print OUT "\thost_name\t\t$host\n";
        print OUT "}\n\n";

      } elsif (/flexlm/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tflexlm_template\n";
        print OUT "\thost_name\t\t$host\n";
        print OUT "}\n\n";

      } elsif (/tierfs/) {

        @disks = split(/:/, $hostref->{'classes'});
        foreach $disk (@disks) {
          if($disk =~ /.*disk.*/) {
            @fields = split(/ /, $disk);
            $fields[0] =~ s/disk\=//;
            print OUT "define service{\n";
            print OUT "\tuse\t\t\tdiskusage_template\n";
            print OUT "\thost_name\t\t$host\n";
            print OUT "\tcheck_command\t\tssh-check-disk!$fields[0]!$fields[1]!$fields[2]\n";
            print OUT "\tservice_description\t$fields[0] usage\n";
            print OUT "}\n\n";
          }
        }

      } elsif (/ldap\.server\.db/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tldap_template\n";
        print OUT "\thost_name\t\t$host\n";
        print OUT "}\n\n";

      } elsif (/drbd/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tdrbd_template\n";
        print OUT "\thost_name\t\t$host\n";
        print OUT "}\n\n";

      } elsif (/krb/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tkrb_template\n";
        print OUT "\thost_name\t\t$host\n";
        print OUT "}\n\n";

      }

    }

  }

  print OUT "# EOF\n";
  close(OUT);

  die "$PNAME: ERROR: Failed to rename $file: $!\n"
    if(!rename("$PATH_TMPFILE", "$file"));

  # send new config file to each server
  system($SCP, '-pq', $file, "storm:/etc/nagios3/conf.d/");
  if ( $? != 0 ) {
    warn "$PNAME: ERROR: Failed to copy nagios files to $host\n";
  }

  system($SSH, '-x', 'storm', '/etc/init.d/nagios3 restart');

}

# 
# FUNCTION: build_wpkg_hosts
#    DESCR: Generate the wpkg hosts.xml file
#

sub build_wpkg_hosts {
  my($file, $include) = @_;
  my(@hosts) = keys(%$cdb_by_hostname);
  my(@inctext, $primgrp, $aliases, $tabs, $hostref);

  @g_sort_order = ( 'ip_addr' ); 
  @hosts = sort sort_hostnames @hosts;

  $PATH_TMPFILE = $file . '.tmp';

  open(OUT, ">$PATH_TMPFILE") ||
    die "$PNAME: ERROR: Failed to open $PATH_TMPFILE: $!\n";

  print OUT '<?xml version="1.0" encoding="UTF-8"?>', "\n";

  print OUT "<!--\n",
    "FILE: $file\n",
    "DESCR: wpkg hosts.xml generated by $PNAME version $PVERS\n",
    "DATE: ", get_date(), "\n",
    "-->\n\n";

  print OUT '<wpkg>', "\n";

  if(-s ("$include")) {
    open(INCLUDE, "<$include") ||
      die "$PNAME: ERROR: Failed to open include $include: $!\n";

    @inctext = <INCLUDE>;
    print OUT @inctext;
    close(INCLUDE);
  }

  foreach $host (@hosts) {

    $hostref = $cdb_by_hostname->{$host};
    $prim_grp = $hostref->{'prim_grp'};
    $os = $hostref->{'os_type'};

    next unless($cdb_primary_groups{$prim_grp} & $NG_WPKG);
    next unless(($os eq 'winxp') or ($os eq 'vista'));

    # generate profile list

    @wpkg_profiles = ();

    my @classes = split(/,/, $hostref->{'classes'});

    if ($os eq 'winxp') {
      push @wpkg_profiles, "winxp";
    } elsif ($os eq 'vista') {
      push @wpkg_profiles, "vista";
    }

    for (@classes) {

      if (/^desktop$/) {
        push @wpkg_profiles, "desktop";
        push @wpkg_profiles, "$os-dept";
      }

      if (/^classroom$/) {
        push @wpkg_profiles, "classroom";
      }

      if (/^maya$/) {
        push @wpkg_profiles, "maya";
      }

      if (/^tstaff$/) {
        push @wpkg_profiles, "tstaff";
      }

      if (/^afs$/) {
        push @wpkg_profiles, "afs";
      }

      if (/^fun$/) {
        push @wpkg_profiles, "fun";
      }

      if (/^research$/) {
        push @wpkg_profiles, "research";
        push @wpkg_profiles, "$os-research";
      }

      if (/^server$/) {
        push @wpkg_profiles, "server";
      }

      if (/^remote$/) {
        push @wpkg_profiles, "desktop";
        push @wpkg_profiles, "remote";
        push @wpkg_profiles, "$os-remote";
      }

      if (/^laptop$/) {
        push @wpkg_profiles, "$os-laptop";
      }

      if (/^laptop.loaner$/) {
        push @wpkg_profiles, "$os-laptop";
        push @wpkg_profiles, "loaner-laptop";
      }

      if (/^laptop.x61$/) {
        push @wpkg_profiles, "$os-laptop";
        push @wpkg_profiles, "x61";
      }

      # licensed software

      if (/^adobe-ae-pp$/) {
        push @wpkg_profiles, "adobe-ae-pp";
      }

      if (/^framemaker$/) {
        push @wpkg_profiles, "framemaker";
      }

      if (/^powerdvd$/) {
        push @wpkg_profiles, "powerdvd";
      }

    }

    next unless @wpkg_profiles;

    $first_profile = shift(@wpkg_profiles);

    print OUT "  <host name=\"$host\" profile-id=\"$first_profile\">\n";
    foreach $profile (@wpkg_profiles) {
      print OUT "    <profile id=\"$profile\" />\n";
    }
    print OUT "  </host>\n";
  }

  print OUT '</wpkg>', "\n";
  close(OUT);

  die "$PNAME: ERROR: Failed to rename $file: $!\n"
    if(!rename("$PATH_TMPFILE", "$file"));

}


#
# FUNCTION: setup_dns_db
#    DESCR: Setup the temporary db file in which all other DNS entries are
#           added.  Write the header information and any include entries.
#
sub setup_dns_db {
  my($file, $include, $fh) = @_;
  # Create temporary file for db - if opt_X, create in current directory

  $db = $CDB_DNS_DIR . '/' . $file unless $opt_X;

  $dbinc = $CDB_INCLUDE_DIR . "/" . $include;

  # Set up headers of the db file

  build_dns_headers($db, $include, $fh) ||
    die "$PNAME: aborting\n";

  # add the include file 

  if(-f("$dbinc")) {
    open(DBINC, "<$dbinc") || die "$PNAME: ERROR: Failed to open $dbinc: $!\n";
    while(<DBINC>) { print $fh $_; }
    close(DBINC);
  }
}

#
# FUNCTION: build_dns_headers
#    DESCR: Creates the specified file, and adds the first specified header 
#           lines from the old file to the new file.
#

sub build_dns_headers {
  my($file, $include, $handle) = @_;
  my($line, $head, $tail, @nums, @inctext);

  print "building headers from: $file, $include\n" if ($opt_v);

  # Open existing database file for reading.  If file doesn't exist, we
  # assume this is an error.

  if (!open(FILE, $file)) {
    warn "$PNAME: ERROR: Failed to open $file: $!\n";
    return 0;
  }

  # Print existing comments and blank lines to new file

  if (eof(FILE)) {
    warn "$PNAME: ERROR: File $file is empty.\n";
    return 0;
  }
 
#  $line = <FILE>; 
#  while ((($line =~ /^\s*$/) || ($line =~ /^;/)) && !eof(FILE)) {
#    print $handle $line;
#    $line = <FILE>;
#  }

  # first line should be ttl line
  $line = <FILE>; 
  if (!($line =~ /ttl/)) {
    warn "$PNAME: ERROR: $file does not being with ttl entry\n";
    return 0;
  }

  print $handle $line;


#  close(FILE);

  # next line should be SOA entry
  $line = <FILE>;
  if (!($line =~ /SOA/)) {
    warn "$PNAME: ERROR: $file does not begin with SOA entry\n";
    return 0;
  }

  # Retrieve serial number from SOA line

  ($head, $tail) = split(/\(/, $line);
  @nums = split(/\s+/, $tail);
  shift(@nums);

  # Recreate line and print it to file  
           
  $line = $head . '( ' . (shift(@nums) + 1);
  while ($_ = shift(@nums)) {
    $line .= " $_";
  }
  print $handle "$line\n";

  # retrieve the remainder of the header information, up to the ; EOH comment
  while(<FILE>) {
    print $handle $_;
    last if /^\; EOH$/;
  }
  
  # print out extra line
  print $handle "\n";

  close(FILE);

  if(-s ("$include")) {
    if (!open(INCLUDE, "<$include")) { 
      warn "$PNAME: ERROR: Failed to open include $include: $!\n";
      return 0;
    }

    @inctext = <INCLUDE>;
    print $handle @inctext;
    close(INCLUDE);
  }
  
  return 1;
}

#
# FUNCTION: build_dns
#    DESCR: Creates the necessary dns-related files and reloads named
#

sub build_dns {
  my($db_header, $i, @dbfiles, $tmpfile, $handle, @handles, %indices, @aliases, 
     $line, $spaces, $host, $cname, @nibbles, $subnet, $dbinc);

  my(%handles, $file, @files);

  # build headers for all the forward lookup maps
  foreach $db (@CDB_DNS_FWD_DBS) {
    # specify the current source files
    if ($opt_X) {
      $db_header = 'db.';
    } else {
      $db_header = $CDB_DNS_DIR . '/db.';
    }
    $srcfile = $db_header . $db;
    $srcinc = $CDB_INCLUDE_DIR . '/cdb_dns_' . $db . '.in';

    # open up a temporary file to house the new db info
    $file = $db_header . $db;

    $handle = $db;
    open($handle, ">$file.tmp") ||
      die "$PNAME: ERROR: Failed to open $file: $!\n";

    push @files, $file;
    $handles{$db} = $handle;

    build_dns_headers($srcfile, $srcinc, $handle);
  }

  # build headers for all the reverse lookup maps
  
  # class C subnets first
  foreach $subnet (@cdb_classC_subnets) {
    # specify the current source files
    if ($opt_X) {
      $db_header = "db.128.148.";
    } else {
      $db_header = $CDB_DNS_DIR . '/db.128.148.';
    }
    $srcfile = $db_header . $subnet;
    $srcinc = $CDB_INCLUDE_DIR . '/cdb_dns_128.148.' . $subnet . '.in';

    # open up a temporary file to house the new db info
    $file = $db_header . $subnet;

    $handle = $subnet;
    open($handle, ">$file.tmp") ||
      die "$PNAME: ERROR: Failed to open $file: $!\n";

    push @files, $file;
    $handles{$subnet} = $handle;

    build_dns_headers($srcfile, $srcinc, $handle);
  }

  # class B subnets next
  foreach $subnet (@cdb_classB_subnets) {
    # specify the current source files
    if ($opt_X) {
      $db_header = "db.10.";
    } else {
      $db_header = $CDB_DNS_DIR . '/db.10.';
    }
    $srcfile = $db_header . $subnet;
    $srcinc = $CDB_INCLUDE_DIR . '/cdb_dns_128.148.' . $subnet . '.in';

    # open up a temporary file to house the new db info
    $file = $db_header . $subnet;

    $handle = $subnet;
    open($handle, ">$file.tmp") ||
      die "$PNAME: ERROR: Failed to open $file: $!\n";

    push @files, $file;
    $handles{$subnet} = $handle;

    build_dns_headers($srcfile, $srcinc, $handle);
  }

  foreach $host (keys(%$cdb_by_hostname)) {
    my($prim_grp) = $cdb_by_hostname->{$host}{'prim_grp'};

    # Don't add DNS entries for dynamic hosts
    next unless ($cdb_primary_groups{$prim_grp} & $NG_DNS);

    # only include hosts that are listed as active or monitored
    $status = $cdb_by_hostname->{$host}{'status'};
    next unless ( $status eq "active" || $status eq "monitored" || $status eq "ugrad-monitored" );

    # first write out to forward tables
    if ("$prim_grp" eq "ilab") {
      $handle = $handles{$prim_grp};
    } else {
      $handle = $handles{'cs'};
    }

    $spaces = ' ' x (21 - length($host));
    $line = $host . $spaces . "IN  A     " .  
      $cdb_by_hostname->{$host}{'ip_addr'};
    print $handle "$line\n";

    if ($cdb_by_hostname->{$host}{'aliases'} ne '') {
      @aliases = split(/,/, $cdb_by_hostname->{$host}{'aliases'});
      while ($cname = pop(@aliases)) {
        $spaces = ' ' x (21 - length($cname));
        if ("$prim_grp" eq "ilab") {
          $line = $cname . $spaces . "IN  CNAME " . "${host}.ilab.${CDB_DNS_DOMAIN}.";
        } else {
          $line = $cname . $spaces . "IN  CNAME " . "${host}.${CDB_DNS_DOMAIN}.";
        }
        print $handle "$line\n";
      }
    }

    if ($cdb_by_hostname->{$host}{'mxhost'} ne '') {
      $spaces = ' ' x (21 - length($host));
      $line = $host . $spaces . "IN  MX    $CDB_DNS_MXPREF " . 
        $cdb_by_hostname->{$host}{'mxhost'} . ".";
      print $handle "$line\n";
    }

    # Then the appropriate subnet database

    @nibbles = split(/\./, $cdb_by_hostname->{$host}{'ip_addr'});
    if (grep /$nibbles[1]/, @cdb_classB_subnets) {
      $subnet = $nibbles[1];
    } elsif (grep /$nibbles[2]/, @cdb_classC_subnets) {
      $subnet = $nibbles[2];
    }

    $line = "";
    foreach (reverse(@nibbles)) {
      $line .= "${_}.";
    }

    $spaces = ' ' x (18 - length($cdb_by_hostname->{$host}{'ip_addr'}));
    if ("$prim_grp" eq "ilab") {
      $line .= "IN-ADDR.ARPA." . $spaces . "IN  PTR   " .
             "${host}.ilab.${CDB_DNS_DOMAIN}.";
    } else {
      $line .= "IN-ADDR.ARPA." . $spaces . "IN  PTR   " .
             "${host}.${CDB_DNS_DOMAIN}.";
    }

    if (defined($handles{$subnet})) {  
      $handle = $handles{$subnet};
      print $handle "$line\n";
    }
  }

  foreach $handle (keys %handles) {
    close($handle);
  }

  foreach $file (@files) {
    die "$PNAME: ERROR: Failed to rename $file.tmp: $!\n"
      if (!rename("$file.tmp", $file));

    # fix permissions the file
    chown((getpwnam($CDB_MAP_OWNER))[2],
          (getgrnam($CDB_MAP_GROUP))[2], $file) ||
             warn "$PNAME: WARNING: Failed to chown $file: $!\n";

    chmod($CDB_MAP_PERMS, $file) ||
      warn "$PNAME: WARNING: Failed to chmod $file: $!\n";
  }

  foreach $host (@CDB_DNS_SERVERS) {
    system($SCP, '-pq', @files, "$host:/var/cache/bind");
    if ( $? != 0 ) {
      warn "$PNAME: ERROR: Failed to copy DNS files to $host\n";
    }

    system($SSH, '-x', $host, '/usr/sbin/rndc reload');
    if ( $? != 0 ) {
        warn "$PNAME: ERROR: Failed to send DNS reload command to on $host\n";
    }
  }

}

#
# FUNCTION: cdb_build
#    DESCR: Build system maps from database.
#

sub cdb_build {
  my(@args) = @_;
  my(@maps) = (@args > 0) ? @args : keys(%g_cdb_maps);
  my($hostname, $file, $include, $mkstate);

  if(@args > 0) {
    foreach $map (@maps) {
      die "$PNAME: Unknown map \"$map\"\n" if(!defined($g_cdb_maps{$map}));
    }
  }

  chop($hostname = `uname -n | awk -F. '{print $1}' 2>/dev/null`);
  $hostname =~ s/\..*$//;

  if($hostname ne $ADMINHOST) {
    die "$PNAME: ERROR: You may only build from \"$ADMINHOST\"\n"
      unless($opt_X);
  }

  die "$PNAME: ERROR: You must be root to run a make\n"
    if($> != 0 && !$opt_X);

  # Even though we're only reading the database, write-lock it so we make
  # sure simultaneous builds don't occur, which might screw up NIS maps, etc.

  $mkstate = load_make_state($PATH_MKFILE);

  foreach $map (@maps) {

    if(defined($cdb_map_files{$map})) {
      $file = $cdb_map_files{$map};
      $file =~ s/^\/etc\/// if($opt_X);
      $include = $cdb_map_includes{$map};
    } else {
      $file = 0;
      $include = 0;
    }

    printflush('STDOUT', "Building $map ... ");
    &{ $g_cdb_maps{$map} }($file, $include);
    update_make_state($mkstate, $map);
    printflush('STDOUT', "done\n");

    if($file && $map ne 'dns') {
      chown((getpwnam($CDB_MAP_OWNER))[2],
            (getgrnam($CDB_MAP_GROUP))[2], $file) ||
              warn "$PNAME: WARNING: Failed to chown $file: $!\n";

      chmod($CDB_MAP_PERMS, $file) ||
        warn "$PNAME: WARNING: Failed to chmod $file: $!\n";
    }
  }

  printflush('STDOUT', "Pushing NIS maps ... ");

  if($opt_v) {
    system("/u/system/bin/ypmake");
  } else {
    system("/u/system/bin/ypmake >/dev/null");
  }

  die "$PNAME: ERROR: Failed to propagate NIS maps\n" if($? != 0);
  printflush('STDOUT', "done\n");

  write_make_state($mkstate, $PATH_MKFILE);
  return 0;
}

#
# FUNCTION: cdb_make
#    DESCR: Dynamically rebuild maps based on changes.
#

sub cdb_make {
  my(@args) = @_;

  my($opt_n) = 0; # Print commands to be executed, but don't execute them
  my($opt_P) = 0; # Report dependency information, but don't build anything

  my($mkstate, $modtime, $bldtime, $arg);
  my($hostname, $str, $file, $include, $mkall);
  my(@stbuf1, @stbuf2);
  my($tcnt) = 0;
  my(@targets) = ();
  my(@files) = ( $PATH_CFFILE, $PATH_DBFILE );

  # Parse the remaining command-line arguments

  while(scalar(@args) > 0) {
    $arg = shift(@args);
    if(substr($arg, 0, 1) eq '-') {
      if($arg eq '-P') {
        $opt_P = 1;
      } elsif($arg eq '-n') {
        $opt_n = 1;
      } else {
        die "$PNAME: illegal make option -- $arg\n";
      }
    } elsif(defined($g_cdb_maps{$arg})) {
      push(@targets, $arg);
    } else {
      die "$PNAME: Unknown map \"$arg\"\n";
    }
  }

  # Check all targets if no targets were specified explicitly

  @targets = keys(%g_cdb_maps) if(scalar(@targets) == 0);

  # If -P is specified, just report latest dependency information and return

  if($opt_P) {
    $mkstate = load_make_state($PATH_MKFILE);

    # Print out which files we're using

    print "Configuration file $PATH_CFFILE\n";
    print "Database file $PATH_DBFILE\n\n";

    # If special files are more recent than make state file itself,
    # then all maps will be rebuilt since they depend on these special files

    @stbuf1 = stat($PATH_MKFILE);
    push(@files, values(%cdb_map_includes));

    foreach $file (@files) {
      @stbuf2 = stat($file);
      next if(scalar(@stbuf2) == 0);

      if($stbuf2[$ST_MTIME] > $stbuf1[$ST_MTIME]) {
        foreach $map (keys(%$mkstate)) {
          $str  = defined($cdb_map_files{$map}) ? $cdb_map_files{$map} : $map;
          $str .= ":\t$file\n";
          print $str;
        }
        return 0;
      }
    }

    # Otherwise pull dependencies from make state file

    foreach $map (keys(%$mkstate)) {
      $modtime = $mkstate->{$map}->[$MK_MODTIME];
      $bldtime = $mkstate->{$map}->[$MK_BLDTIME];

      if($bldtime <= $modtime) {
        $modtime = $modtime == 0 ? 'unknown' : fmt_time($modtime);
        $bldtime = $bldtime == 0 ? 'unknown' : fmt_time($bldtime);

        $str  = defined($cdb_map_files{$map}) ? $cdb_map_files{$map} : $map;
        $str .= ":\tlast build $bldtime, modified $modtime\n";
        
        print $str;
        $tcnt++;
      }
    }
 
    print "All targets are up to date.\n" if($tcnt == 0);
    return 0;
  }

  # Otherwise iterate through targets building whatever has been modified

  chop($hostname = `uname -n 2>/dev/null`);
  $hostname =~ s/\..*$//;

  if($hostname ne $ADMINHOST) {
    die "$PNAME: ERROR: You may only build from \"$ADMINHOST\"\n"
      unless($opt_X);
  }

  die "$PNAME: ERROR: You must be root to build NIS maps\n"
    if($> != 0 && !$opt_X && !$opt_n);

  # Even though we're only reading the database, write-lock it so we make
  # sure simultaneous builds don't occur, which might screw up NIS maps, etc.

  $mkstate = load_make_state($PATH_MKFILE);

  # If special files are more recent than make state file itself,
  # then all maps will be rebuilt since they depend on these special files

  @stbuf1 = stat($PATH_MKFILE);
  push(@files, values(%cdb_map_includes));
  $mkall = 0;

  foreach $file (@files) {
    @stbuf2 = stat($file);
    next if(scalar(@stbuf2) == 0);
    if($stbuf2[$ST_MTIME] > $stbuf1[$ST_MTIME]) {
      $mkall = 1;
      last;
    }
  }

  # Examine targets list and rebuild map if necessary

  foreach $map (@targets) {
    next if(!$mkall &&
            $mkstate->{$map}->[$MK_BLDTIME] > $mkstate->{$map}->[$MK_MODTIME]);

    $tcnt++;

    if($opt_n) {
      print "cdb build $map\n";
      next;
    }

    if(defined($cdb_map_files{$map})) {
      $file = $cdb_map_files{$map};
      $file =~ s/^\/etc\/// if($opt_X);
      $include = $cdb_map_includes{$map};
    } else {
      $file = 0;
      $include = 0;
    }

    printflush('STDOUT', "Building $map ... ");
    &{ $g_cdb_maps{$map} }($file, $include);
    update_make_state($mkstate, $map);
    printflush('STDOUT', "done\n");

    if($file && $map ne 'dns') {

      chown((getpwnam($CDB_MAP_OWNER))[2],
            (getgrnam($CDB_MAP_GROUP))[2], $file) ||
              warn "$PNAME: WARNING: Failed to chown $file: $!\n";

      chmod($CDB_MAP_PERMS, $file) ||
        warn "$PNAME: WARNING: Failed to chmod $file: $!\n";
    }
  }

  # Push out NIS maps, unless -n was specified

  unless($opt_n) {
    printflush('STDOUT', "Pushing NIS maps ... ");
    if($opt_v) {
      system("/u/system/bin/ypmake");
    } else {
      system("/u/system/bin/ypmake >/dev/null");
    }
    die "$PNAME: ERROR: Failed to propagate NIS maps\n" if($? != 0);
    printflush('STDOUT', "done\n");
    write_make_state($mkstate, $PATH_MKFILE);
  }

  print "All targets are up to date.\n" if($tcnt == 0);
  return 0;
}

# Parse the command-line, load the database file, and execute a command

my $help = 0;
my $verbose = 0;
my $version = 0;
my $username = $ENV{'USER'};

GetOptions ('help|h|?' => \$help, 
            'v|verbose' => \$verbose,
            'version' => \$version,
            'u' => \$username) or usage(2);
usage(1) if $help;

if ($version) {
  print $VERSION;
  exit(0);
}

if (@ARGV == 0) {
  usage(0);
}

# Load the configuration file and perform some checking on it

die "$PNAME: $PATH_CFFILE: $!\n" unless(-f("$PATH_CFFILE"));
eval('require("$PATH_CFFILE");');
die "$PNAME: Failed to load $PATH_CFFILE: $@\n" if($@);

die "$PNAME: $PATH_CFFILE must define CDB_BOOT_TYPE\n"     unless(defined($CDB_BOOT_TYPE));
die "$PNAME: $PATH_CFFILE must define CDB_DBF_GROUP\n"     unless(defined($CDB_DBF_GROUP));
die "$PNAME: $PATH_CFFILE must define CDB_DBF_PERMS\n"     unless(defined($CDB_DBF_PERMS));
die "$PNAME: $PATH_CFFILE must define CDB_DHCP_SERVERS\n"  unless(defined(@CDB_DHCP_SERVERS));
die "$PNAME: $PATH_CFFILE must define CDB_DNS_MXPREF\n"    unless(defined($CDB_DNS_MXPREF));
die "$PNAME: $PATH_CFFILE must define CDB_DNS_FWD_DBS\n"   unless(defined(@CDB_DNS_FWD_DBS));
die "$PNAME: $PATH_CFFILE must define CDB_DNS_SERVERS\n"   unless(defined(@CDB_DNS_SERVERS));
die "$PNAME: $PATH_CFFILE must define CDB_MAP_GROUP\n"     unless(defined($CDB_MAP_GROUP));
die "$PNAME: $PATH_CFFILE must define CDB_MAP_GROUP\n"     unless(defined($CDB_MAP_OWNER));
die "$PNAME: $PATH_CFFILE must define CDB_MAP_PERMS\n"     unless(defined($CDB_MAP_PERMS));
die "$PNAME: $PATH_CFFILE must define CDB_NETGROUP_DIRS\n" unless(defined(@CDB_NETGROUP_DIRS));
die "$PNAME: $PATH_CFFILE must define NG_DHCP\n"           unless(defined($NG_DHCP));
die "$PNAME: $PATH_CFFILE must define NG_WPKG\n"           unless(defined($NG_WPKG));

# Install signal handlers

$SIG{'INT'} = \&sighandler;
$SIG{'HUP'} = \&sighandler;
$SIG{'TERM'} = \&sighandler;

# Execute the appropriate subcommand

if(defined($g_cdb_commands{$ARGV[0]})) {
  $g_cmdname = shift(@ARGV);
  my $password = BrownCS::UDB->get_pass;
  $udb->start($username, $password);
  $g_status = &{ $g_cdb_commands{$g_cmdname}{'fn'} }(@ARGV);
  $udb->finish;
  exit($g_status);
}

die "$PNAME: Invalid command -- $ARGV[0]\n$USAGE";

__END__

=head1 NAME

cdb - Client database front-end

=head1 SYNOPSIS

cdb [-hv] command [args ...]

=head1 DESCRIPTION

The client database is a simple database of network clients which can be used
to automatically generate system-wide configuration files, such as NIS maps,
DNS zone files, and network boot information.  Each record in the database
corresponds to a network connection, i.e. a unique IP address.  In most cases,
each record also corresponds to a single machine connected to the network, but
this is not always the case.  A single logical machine may have multiple
network interfaces, and will therefore have multiple database entries.
Additionally, some network devices with names and IP addresses may not
correspond to a workstation; there may be entries for networked printers,
dialup multiplexors, and other devices.

The B<cdb> database front-end program reads in the latest copy of the database
and a configuration file describing various parameters for the domain, and then
allows the user to add, remove, or modify records, or to perform simple
queries.  Using the front-end also reduces errors: all names and addresses are
automatically converted to standard formats, and the database automatically
checks for conflicts, preventing duplicate hostnames or addresses from being
entered into the database.  If changes have been made, the B<cdb make> command
is used to rebuilt all system configuration files which will be affected by the
changes.  The database modifications may be performed safely by any user with
appropriate privileges from any machine.  The rebuild command must be issued as
root from the NIS master machine.

Each client stored in the database must belong to a designated primary
netgroup, which must be described in the database configuration file, and may
also belong to one or more supplementary netgroups.  Based on the client's
primary group, the information for a record will be output to one or more
system-wide maps when they are generated from the database.  This allows the
administrator to configure, for example, a primary group for which
B<hosts.equiv(4)> entries will be generated, and another primary group for
which they will not.  All primary groups and the maps they will produce are
defined in the database configuration file.

Each database record consists of a set of fields which are stored as ASCII
text strings.  Certain fields are mandatory and must contain legal values.
Other fields are optional, and may be left blank.  The front-end software
enforces these policies so that the user cannot insert an invalid record.
The fields associated with each record are:

.SS "hostname"
The client's unqualified Internet hostname.  This field is guaranteed to be
unique in the database.
.SS "aliases"
A comma-separated list of Internet host aliases.  Each alias is guaranteed to
be unique to both the aliases and hostname fields across all database records.
.SS "prim_grp"
The client's primary netgroup.  This field is verified to be a valid primary
group in the database configuration file.
.SS "supp_grps"
A comma-separated list of supplementary netgroups.  This field may be left
blank, or set to a list of arbitrary netgroup names, which must not be the
names of any known primary group.  When the
.BR netgroup(4)
map is generated, entries for all known supplementary netgroup names will be
created.
.SS "ip_addr"
The client's IP address in dotted-decimal format.  This field is always required
and it guaranteed to be unique across all database records.
.SS "ethernet"
The client's 48-bit ethernet address.  This field is guaranteed to be unique
across all database records.  The field may be left blank, unless the record's
primary group is used to generate the
.BR ethers(4)
map, in which case it is required.
.SS "hw_arch"
The client's hardware architecture.  This field is typically set to the output
of the
.BR uname(1) \-m
command run on the client machine.  This field may be left blank, unless the
record's primary group is used to generate a
.BR tftp(1)
network boot image, in which case it is required.
.SS "os_type"
The client's operating system type string.  This field may be left blank, unless
the client's primary group is used to generate the
.BR bootparams(4)
map, it which case it is required and must be set to one of the valid operating
system types defined in the database configuration file.
.SS "mxhost"
The fully-qualified Internet name of another host which exchanges electronic
mail for the client.  If not blank, this field is used to generate MX records
in the DNS zone files created by the front-end.
.SS "port"
The client's network port.  This field is entirely optional, and is meant to
be used to record the network jack number to which the client is connected.
.SS "comment"
An arbitrary comment describing the host.  This field may be left blank.
.SS "status"
The current machine status, selected from the legal status strings set
in the configuration file.

=head1 OPTIONS

=over

.TP
.BI "\-h"
Display a list of commands and options.
.TP
.BI "\-V"
Display version information.
.TP
.BI "\-v"
Set verbose mode.
.TP
.BI "\-f"
Force creation of a new empty database if specified database is not found.
.TP
.BI "\-s field"
Sort output by specified field name.  Use ``cdb print'' for a list of fields.
Output is unsorted if no -s option is specified.
.TP
.BI "\-d delim"
Specify output delimeter.  Fields are delimited by tabs or newlines where
appropriate if no -d option is specified.
.TP
.BI "\-b dbfile"
Specify pathname of an alternate database file.  The database
/u/system/lib/cdb_data.pl is used if no -b option is specified.
.TP
.BI "\-c configfile"
Specify pathname of an alternate configuration file.  The configuration file
/u/system/lib/cdb_config.pl is used if no -c option is specified.
.TP
.BI "cdb print [field ...]"
Print specified fields of all records.
.TP
.BI "cdb query [field[=regexp] ...]"
Print records matching criteria.
.TP
.BI "cdb insert"
Interactively insert a new client record.
.TP
.BI "cdb modify [hostname [field=value ...]]"
Modify specified client record.
.TP
.BI "cdb delete [hostname ...]"
Delete specified records.
.TP
.BI "cdb joingrp grpname hostname ..."
Add hosts to supplementary netgroup.
.TP
.BI "cdb rmgrp grpname [hostname ...]"
Remove some or all hosts from specified supplementary netgroup.
.TP
.BI "cdb groups [hostname]"
List netgroups to which a given host belongs, or list all netgroups.
.TP
.BI "cdb grplist grpname"
List members of specified netgroup.
.TP
.BI "cdb profile hostname"
Print summary of specified client record.
.TP
.BI "cdb build [map ...]"
Force rebuild of one or all system maps.
.TP
.BI "cdb make [-P] [-n] [map ...]"
Rebuild maps which need to be updated based on changes since last build.
.TP
.BI "cdb search hostname [dir1...]"
Search jumpstart tree for host.xxx and netgroup.xxx files.
.TP
.BI "cdb find hostname pathname"
Search a host's jumpstart tree for a specific pathname.
=item B<-h>, B<--help>

Print a help message and exit.

=item B<-n>

Do nothing.  Runs rsync in dry-run mode - does not actually update
anything, but reports which files would be updated.

=item B<-v>

Verbose.  The normal webupdate output shows only files updated.  This
option shows links and directories updated, and deletions, too.  The
format differs, as this turns on rsync's verbose option.

=item B<-x>

Print the exclude file that would be given to rsync.

=back

=head1 COMMANDS

.SS "cdb print [field ...]"
.TP
.B "DESCRIPTION"
Print the specified fields from each database record.  Field names are printed
in order and separated by tabs, or the delimiter specified with the
.B \-d
option.  The output is unsorted unless a sort order is specified with the
.B \-s
option.  If no options are specified, a list of the valid field names is
printed.
.TP
.B "OPTIONS"
.TP 5
.I "field"
The name of a field whose value should be printed.
.SS "cdb query [field[=regexp] ...]"
.TP
.B "DESCRIPTION"
Query the database for fields whose values match the specified regular
expressions, and then print the specified fields corresponding to each record.
Each argument to this command is interpreted as either matching criteria or
the name of a field to print in the output.  Field names are printed in order
and separated by tabs, or the delimiter specified with the
.B \-d
option.  The output is unsorted unless a sort order is specified with the
.B \-s
option.
.TP
.B "OPTIONS"
.TP 5
.I "field"
The name of a field whose value should be printed in the output.
.TP 5
.I "field=regexp"
The name of a field which should be used as matching criteria.  The field will
not be printed in the output unless it is also specified alone without the
.I =regexp
suffix on the command line.  The
.I regexp
argument is expected to be in Perl regular expression format (see
.BR perlre(l)
for the complete syntax), and may require quoting to prevent regular expression
meta-characters from being interpreted as shell meta-characters.  Records are
matched if they match the logical 
.B and
of the selection criteria.
.SS "cdb insert"
.TP
.B "DESCRIPTION"
Interactively insert a new database record.  The user will be prompted for the
value of each field, which will be converted to an appropriate canonical format
if possible, and verified to be valid and unique where appropriate.  At any
time, the user may type a question-mark (``?'') and press return to view help
information on the current field.  The administrator should execute
.B cdb make
after inserting a new database record.
.SS "cdb modify [hostname [field=value ...]]"
.TP
.B "DESCRIPTION"
Modify one or more fields of an existing database record.  If no hostname
is specified, the user is interactively prompted for the hostname of the record
to modify.  If only a hostname is specified, the user is interactively prompted
for which fields to modify and their new values.  If a hostname and one or more
.I "field=value"
arguments are specified, the specified values are set to the given values and
the front-end immediately exits and saves the modifications.  In all cases,
each new field value is converted to a canonical format if appropriate and
validated using the previously described requirements for each field.  The
front-end will not save invalid modifications to the database.  In interactive
mode, the user will be prompted to save changes at the end of the modifications.
The administrator should execute
.B cdb make
after modifying a database record.
.TP
.B "OPTIONS"
.TP 5
.I "hostname"
The value of the hostname field identifying the record to be modified.
.TP 5
.I "field=value"
Set the specified field to the specified value.  Any number of these arguments
may be present on the command line.  If the new value contains whitespace or
shell meta-characters, it may be necessary to use appropriate shell quoting
syntax to surround the argument on the command line.
.SS "cdb delete [hostname ...]"
.TP
.B "DESCRIPTION"
Delete one or more client records, identified by their hostnames, from the
database.  The administrator should execute
.B cdb make
after deleting database records.
.TP
.B "OPTIONS"
.TP 5
.I "hostname"
The value of the hostname field identifying the record to be deleted.  One or
more hostnames may be specified on the command line.
.SS "cdb joingrp grpname hostname ..."
.TP
.B "DESCRIPTION"
Add one or more hosts to a supplementary netgroup.  If the group does not exist,
it will be automatically created the next time the netgroup map is rebuilt.
The administrator should execute
.B cdb make
after machines join new groups.
.TP
.B "OPTIONS"
.TP 5
.I "grpname"
The name of the supplementary group to join.  This must be a string of
alphanumeric characters which is not the name of an existing primary netgroup.
.TP 5
.I "hostname"
The value of the hostname field identifying a record whose
.B supp_grps
field should be modified to include the specified
.I grpname
.
.SS "cdb rmgrp grpname [hostname ...]"
.TP
.B "DESCRIPTION"
Remove one or more or all hosts from a supplementary netgroup.  If one or more
hostnames are specified on the command line, the specified netgroup is removed
from the
.B supp_grps
field of each record.  If only a netgroup name is given on the command line,
the specified netgroup is removed from all client records, effectively removing
the netgroup.  The administrator should execute
.B cdb make
after removing a supplementary netgroup from client records.
.TP
.B "OPTIONS"
.TP 5
.I "grpname"
The name of the supplementary group to remove.  This must be a string of
alphanumeric characters which is not the name of an existing primary netgroup.
.TP 5
.I "hostname"
The value of the hostname field identifying a record whose
.B supp_grps
field should be modified to not include the specified
.I grpname
.
.SS "cdb groups [hostname]"
.TP
.B "DESCRIPTION"
Print the list of netgroups (including both primary and supplementary groups)
to which the specified host belongs, or print the complete list of netgroups
in the database (if no hostname argument is specified on the command line).
The names are delimited by tabs or newlines, or by the delimiter specified by
the
.B \-d
option.
.TP
.B "OPTIONS"
.TP 5
.I "hostname"
The value of the hostname field identifying a record whose
.B prim_grp
and
.B supp_grps
fields should be printed.
.SS "cdb grplist grpname"
.TP
.B "DESCRIPTION"
List the members of the specified netgroup, which may be either a primary
netgroup name or supplementary netgroup name.  The
.B hostname
field of each matched record is printed, separated by newlines, or by the
delimiter specified by the
.B \-d
option.
.TP
.B "OPTIONS"
.TP 5
.I "grpname"
The name of the primary or supplementary netgroup whose members will be
printed.
.SS "cdb profile hostname"
.TP
.B "DESCRIPTION"
Print a formatted listing of the values of each field of the client record for
the specified hostname.
.TP
.B "OPTIONS"
.TP 5
.I "hostname"
The value of the hostname field identifying a record whose fields should be
printed.
.SS "cdb build [map ...]"
.TP
.B "DESCRIPTION"
Force the rebuild of one or more or all system maps.  In our terminology, a
map is a file or set of files providing some system-wide information which is
automatically built by the front-end from the current contents of the database,
and an optional set of include files.  Typically the administrator does not
need to use this command; instead the
.B cdb make
command is used, which automatically rebuilds on those maps which need to be
built based on the changes made to the database since the last build or make.
However, this command is provided for completeness, and because there may be
some extenuating circumstances where a manual rebuild is necessary.  If no
arguments are given on the command line, all maps are built; otherwise only
those maps whose names are specified are built.
.TP
.B "OPTIONS"
.TP 5
.B "ethers"
The
.B /etc/ethers
file on the NIS master will be rebuilt and pushed out to the clients.  If an
include file is defined for this map in the
.I %cdb_map_includes
hash in the configuration file, it will be included in the output file.
.TP 5
.B "hosts"
The
.B /etc/hosts
file on the NIS master will be rebuilt and pushed out to the clients.  If an
include file is defined for this map in the
.I %cdb_map_includes
hash in the configuration file, it will be included in the output file.
.TP 5
.B "bootparams"
The
.B /etc/bootparams
file on the NIS master will be rebuilt and pushed out to the clients.  If an
include file is defined for this map in the
.I %cdb_map_includes
hash in the configuration file, it will be included in the output file.
.TP 5
.B "netgroup"
The
.B /etc/netgroup
file on the NIS master will be rebuilt and pushed out to the clients.  If an
include file is defined for this map in the
.I %cdb_map_includes
hash in the configuration file, it will be included in the output file.
.TP 5
.B "tftpboot"
The network boot images for client machines, stored in the directory
.B /tftpboot
on the boot server (assumed to be the same machine as the NIS master), will be
recreated.  Using the location of the network boot images specified in the
.I $cdb_os_types
hash in the configuration file, the front-end copies the boot images for each
active operating system type and hardware architecture to files named
.B inetboot.hw_arch.os_type
, where
.I hw_arch
and
.I os_type
correspond to the values of these fields in the corresponding client records.
For each client record of a given hardware architecture and operating system
type, two symbolic links are then created in the
.B /tftpboot
directory to the appropriate inetboot binary.  The first symbolic link is
named by converting each byte of the client record's 4-byte IP address to two
hexadecimal digits (e.g. IP address 128.148.33.114 is converted to link name
80942172).  The second link has the same name as the first, except that a
.I .hw_arch
suffix is added, where the suffix is formed by converting the value of the
client record's
.B hw_arch
field to uppercase letters.  This is needed for compatibility with older
revisions of the OpenBoot PROM software.
.TP 5
.B "dns"
The DNS zone files stored in the
.B /var/named
directory on the primary DNS server for the zone (assumed to be the same machine
as the NIS master) are rebuilt, and the name service daemon is signaled to
re-read the new zone files.  The location of the DNS zone files may be
configured using the
.I $CDB_DNS_DIR
tunable.  The DNS domain name for the site may be configured using the
.I $CDB_DNS_DOMAIN
tunable.  The preference value for DNS MX records generated from the value
of the
.B mxhost
field associated with client records may be configured using the
.I $CDB_DNS_MXPREF
tunable.  Each of these options is stored in the database configuration file.
The DNS serial number is read from the existing files, and is incremented in
the new output files.
.SS "cdb make [-P] [-n] [map ...]"
.TP
.B "DESCRIPTION"
Rebuild system maps exactly as with the
.B cdb build
command described previously, but only rebuild a map if modifications to the
database since the previous
.B cdb build
or
.B cdb make
require that the map be regenerated.  If no map names are specified on the
command line, all maps are checked and rebuilt if necessary.  If one or more
map names are specified, only those maps are checked and rebuilt.
.TP
.B "OPTIONS"
.TP 5
.B \-P
Print detailed dependency information regarding which maps need to be rebuilt
and why, but do not actually rebuild them.  This option is used primarily for
debugging purposes.
.TP 5
.B \-n
Print the names of the maps which need to be rebuilt, but do not actually
rebuild them.  Useful for determining what the result of a
.B cdb make
would be without actually changing the current state of the system.
.TP 5
.I map
Specify the name of a map to be checked and rebuilt if necessary.  The valid
map names are described in the previous section on options to the
.B cdb build
command.

=head1 FILES

.TP
.B /etc/bootparams
.TP
.B /etc/ethers
.TP
.B /etc/named.pid
.TP
.B /etc/netgroup
.TP
.B /u/system/lib/.cdb_make.state
.TP
.B /u/system/lib/cdb_config.pl
.TP
.B /u/system/lib/cdb_data.pl
.TP
.B /var/yp/Makefile

=head1 AUTHORS

Mike Shapiro. DNS database build routines written by Stephanie Schaaf. UDB port
written by Aleks Bromfield.

=head1 SEE ALSO

B<rsync>(1), B<ssh>(1)

.PP
Application programs:
.BR rcp (1)
.BR uname (1)
.BR ypcat (1)
.BR ypmatch (1)
.BR ypwhich (1)
.PP
Maintenance commands:
.BR in.named (1m)
.BR in.rarpd (1m)
.BR in.tftpd (1m)
.BR ypserv (1m)
.PP
File formats:
.BR bootparams (4)
.BR ethers (4)
.BR netgroup (4)
.BR ypfiles (4)
.PP
Local reference:
.BR perl (l)
.BR perlre (l)
.PP

=head1 NOTES

Access to read and write the cdb database file and configuration file is
determined by the UNIX file permissions on these files.  UNIX file locking,
across NFS if necessary, is used to read or write-lock the database file
depending on the type of operation being performed.

The B<cdb> system assumes that all master maps are kept on a single Sun NIS
server, which also serves as the boot server for Solaris network installation.
No provisions have been made for NIS+ at this time.

=head1 BUGS

Doesn't report the removal of files and directories except those
excluded by a .private file.  This is a feature of rsync.

=cut

