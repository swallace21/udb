#!/usr/bin/python

# $Id$

import os
import os.path
import errno
import time
import sys
import globals
import Utils

class Target:
    global buildDir
    buildDir = None
    
    def __init__(self, db):
        self.db = db

    def build(self):
        assert 0, 'NOT REACHED'

    def install(self):
        assert 0, 'NOT REACHED'

    def setBuildDir(dirname):
        global buildDir
        if globals.debug:
            buildDir = '.' + dirname
        else:
            buildDir = dirname
    setBuildDir = staticmethod(setBuildDir)
    
    def getBuildDir():
        if not buildDir:
            Target.setBuildDir(globals.temp_dir)
        return buildDir
    getBuildDir = staticmethod(getBuildDir)

    def clearBuildDir():
        global buildDir
        buildDir = None
    clearBuildDir = staticmethod(clearBuildDir)

class TargetFile(Target):
    def __init__(self, db):
        Target.__init__(self, db)
        self.targetFilename = 'OOPS!  targetFilename should have been over-ridden!'
        self.buildFilename = 'OOPS!  buildFilename should have been over-ridden!'
        self.includeFilename = None
        self.descr = 'OOPS!  descr should have been over-ridden!'

    def getIncludePath(self):
        if globals.debug:
            return './include'
        return globals.include_dir

    def appendContentsOfFilenameToFile(self, filename, out):
        inc = file(filename, 'r')
        for line in inc:
            out.write(line)
        inc.close()
        
    def includeFile(self, include_file, outfile):
        if not os.path.exists(include_file):
            return
        self.appendContentsOfFilenameToFile(include_file, outfile)

    def buildTargetFile(self, out):
        self.addHeader(out)
        self.includeStaticData(out)
        self.addDynamicData(out)
        self.addTrailer(out)
        
    def build(self):
        output = file(self.getBuildFile(), 'w')
        self.buildTargetFile(output)
        output.close()

    def includeStaticData(self, outfile):
        self.includeFile(self.getIncludeFilename(), outfile)

    def install(self):
        Utils.moveFile(self.getBuildFile(), self.getTargetFile())

    def addTrailer(self, out):
        out.write('# EOF\n')

    def getTargetFile(self):
        if globals.debug:
            return './tmp/' + os.path.split(self.targetFilename)[1]
        return self.targetFilename

    def getBuildFile(self):
        return self.getBuildDir() + self.buildFilename

    def getIncludeFilename(self):
        if not self.includeFilename:
            return None
        return self.getIncludePath() + self.includeFilename

    def addHeader(self, out):
        header = """#
#  FILE: %s
# DESCR: %s generated by %s version %s
#  DATE: %s
#
##############################################################################
# DO NOT EDIT THIS FILE BY HAND! ALL DATA IS GENERATED BY CDB.
# USE CDB TO MODIFY OR INSERT RECORDS, OR EDIT %s
##############################################################################
""" % ( self.getTargetFile(), self.descr, globals.prog, globals.version,
        time.ctime(), self.getIncludeFilename() )
        out.write(header)
        
class Ethers(TargetFile):
    def __init__(self, db):
        TargetFile.__init__(self, db)
        self.targetFilename = '/var/yp/src/ethers'
        self.buildFilename = '/ethers'
        self.includeFilename = '/cdb_ethers.in'
        self.descr = 'NIS ethers map'
        
    def addDynamicData(self, outfile):
        result = self.db.getHostnameEthernet()
        for ether, host in result:
            outfile.write("%s\t%s\n" % (ether, host))

class DHCP(TargetFile):
    def __init__(self, db):
        TargetFile.__init__(self, db)
        self.targetFilename = '/maytag/sys0/dhcp/etc/dhcpd.conf'
        self.buildFilename = '/dhcp.conf'
        self.includeFilename = '/cdb_dhcp.in'
        self.descr = 'DHCP config'

    def addDynamicRecord(self, out, host_number, ethernet, comment):
        if comment:
            out.write("    # %s\n" % comment)
        out.write("    host ddhcp-%d {\n" % host_number )
        out.write("        hardware ethernet %s;\n" % ethernet)
        out.write("    }\n")

    def addStaticRecord(self, out, hostname, ethernet):
        out.write("    host %s {\n" % hostname)
        out.write("        hardware ethernet %s;\n" % ethernet)
        out.write("        fixed-address %s;\n" % hostname)
        out.write("    }\n")

    def addDynamicAddresses(self, outfile):
        outfile.write("#\n")
        outfile.write("# Known clients that should receive dynamic addresses\n")
        outfile.write("#\n")
        outfile.write("group {\n")
        outfile.write("    use-host-decl-names on;\n")
        outfile.write("    \n")

        for nid, ether, comment in self.db.getDdhcp():
            self.addDynamicRecord(outfile, nid, ether, comment)
        outfile.write("}\n\n")

    def addStaticAddresses(self, outfile):
        outfile.write("group {\n")
        outfile.write("    use-host-decl-names on;\n")
        outfile.write("    next-server pxe.cs.brown.edu;\n")
        outfile.write('    filename "pxelinux.0";\n')
        outfile.write('\n')

        result = self.db.getHostnameEthernet()
        for ether, host in result:
            self.addStaticRecord(outfile, host, ether)
        outfile.write("}\n")
        
    def addDynamicData(self, outfile):
        self.addDynamicAddresses(outfile)
        self.addStaticAddresses(outfile)

class Hosts(TargetFile):
    def __init__(self, db):
        TargetFile.__init__(self, db)
        self.targetFilename = '/var/yp/src/hosts'
        self.buildFilename = '/hosts'
        self.includeFilename = '/cdb_hosts.in'
        self.descr = 'NIS hosts map'

    def addDynamicData(self, outfile):
        for ip, hostname, aliases in self.db.getHostfile():
            outfile.write("%s\t%s" % (ip, hostname))
            if aliases:
                outfile.write(' ')
                outfile.write(' '.join(aliases))
            outfile.write("\n")

class BootParams(TargetFile):
    def __init__(self, db):
        TargetFile.__init__(self, db)
        self.targetFilename = '/var/yp/src/bootparams'
        self.buildFilename = '/bootparams'
        self.includeFilename = '/cdb_bootparams.in'
        self.descr = 'NIS bootparams map'

    #
    # This method is horribly inefficient.  However, it's not really a
    # problem as there are currently only about 20 hosts in the bootparams
    # file (and shrinking all the time).
    #
    def addDynamicData(self, outfile):
        nids = self.getNids()
        for nid in nids:
            (id, ip, hostname) = self.db.getNetworkBootparams(nid)
            subnet = self.getSubnet(ip)
            os = self.db.getOS(id)
            (netboot_path, install, jumpstart, cache) = self.db.getJSPaths(os)
            (boot_server, boot_path) = install.split(':')
            (js_server, js_path) = jumpstart.split(':')

            outfile.write(hostname +
                          ' root=' + boot_server + subnet + ':' + boot_path + '/' + netboot_path +
                          ' install=' + boot_server + subnet + ':' + boot_path +
                          ' boottype=:in' +
                          ' install_config=' + js_server + subnet + ':' + js_path +
                          ' sysid_config=' + js_server + subnet + ':' + js_path + "\n\n")
                          

    def getSubnet(self, addr):
        return addr.split('.')[2]
    
    def getNids(self):
        nids = []
        for netgroup in globals.netgroups_bootparams:
            nids.extend(self.db.getNetgroup(netgroup))
        return nids

class HostsEquiv(TargetFile):
    def __init__(self, db):
        TargetFile.__init__(self, db)
        self.targetFilename = '/etc/hosts.equiv'
        self.buildFilename = '/hosts.equiv'
        self.includeFilename = '/cdb_hosts.equiv.in'
        self.descr = '/etc/hosts.equiv'

    def getHostsToIncludeInHostsEquiv(self):
        hosts = []
        for netgroup in globals.netgroups_hosts_equiv:
            hosts.extend(self.db.getHostnamesInNetgroup(netgroup))
        return Utils.unique(hosts)
        
    def addDynamicData(self, outfile):
        for host in self.getHostsToIncludeInHostsEquiv():
            outfile.write("%s\n" % (host))
            outfile.write("%s.cs.brown.edu\n" % (host))
        
    #
    # Comments aren't allowed in hosts.equiv, so override these methods
    #
    def addHeader(self, out):
        pass
    def addTrailer(self, out):
        pass

class Netgroup(TargetFile):
    def __init__(self, db):
        TargetFile.__init__(self, db)
        self.targetFilename = '/var/yp/src/netgroup'
        self.buildFilename = '/netgroup'
        self.includeFilename = '/cdb_netgroup.in'
        self.descr = 'NIS netgroup map'

    def addDynamicData(self, outfile):
        for netgroup in self.db.getAllNetgroups():
            self.addNetgroup(outfile, netgroup)

    def makeNetgroupRecord(self, netgroup, host_records):
        return netgroup + '\t' + ' '.join(host_records) + '\n\n'
        
    def writeEntry(self, outfile, group, host_records):
        outfile.write("# Netgroup %s\n\n" % group)
        netgroup_record = self.makeNetgroupRecord(group, host_records)
        for line in Utils.break_lines(netgroup_record): 
            outfile.write(line)

    def addNetgroup(self, out, netgroup):
        hosts = self.db.getHostnamesInNetgroup(netgroup)
        if len(hosts) == 0:
            return
        host_records = [ "(%s,,%s)"
                         % (host, globals.nis_domain) for host in hosts ]
        self.writeEntry(out, netgroup, host_records)
        

class Tftpboot(Target):
    def __init__(self, db):
        #
        # Don't call Target.__init__ here -- it should be done in the
        # init of the sub targets
        #
        self.subTargets = [ TftpbootSun(db), TftpbootLinux(db) ]

    def getBuildDir(self):
        return Target.getBuildDir() + '/tftpboot'
        
    def build(self):
        if not os.path.exists(self.getBuildDir()):
            os.mkdir(self.getBuildDir(), 0700)

        for target in self.subTargets:
            target.build(self.getBuildDir())

    def install(self):
        srcDir = self.getBuildDir()
        dstDir = self.getTargetDir()
        
        links = os.listdir(srcDir)
        for name in links:
            srcFile = srcDir + '/' + name
            dstFile = dstDir + '/' + name
            try:
                Utils.moveFile(srcFile, dstFile)
            except OSError, e:
                Utils.warn("Can't move symlink %s to %s" % (srcFile, dstFile),
                            e)

    def getTargetDir(self):
        if globals.debug:
            return '/tmp'
        return globals.tftp_dir
        
    def ip2hex(self, ip):
        nibbles = ip.split('.')
        hex_nibbles = [ "%0.2X" % int(n) for n in nibbles]
        return ''.join(hex_nibbles)

class TftpbootSun(Tftpboot):
    def __init__(self, db):
        Target.__init__(self, db)

    #
    # This method requires some explaination.  A boot image exists somewhere
    # on a boot server.  The server name is included in a data base table.
    # We check to see if the boot image lives in the *actual* tftp directory.
    # If doesn't we need to copy it from the boot server into the build
    # directory (the install() method will later move it to the tftp dir.)
    #
    def build(self, build_dir):
        Utils.verbose(1, 'Sun...')
        self.bootimages = {}

        for nid in self.db.getNetgroup('sun'):
            (id, ip, hostname) = self.db.getNetworkBootparams(nid)
            os_type = self.db.getOS(id)
            arch = self.db.getArch(id)
            self.boot_file = "inetboot.%s.%s" % (arch, os_type)

            if (os_type, arch) not in self.bootimages:
                self.bootimages[(os_type, arch)] = build_dir \
                                                   + '/' + self.boot_file
                self.ensureBootImageExists(build_dir, os_type, arch)
                                                                       
            hexip = build_dir + '/' + self.ip2hex(ip)
            hexip_arch = hexip + '.' + arch

            Utils.make_link(self.boot_file, hexip)
            Utils.make_link(self.boot_file, hexip_arch)

        #
        # clean up unneeded instance variables
        #
        self.bootimages = None
        self.boot_file = None

    #
    # Check to see if the boot image exists in the real tftp directory.
    # If not, copy it from the boot server to the build directory.  The
    # file on the server has to be given a different name in the build
    # directory.  Example:
    # On the boot server, the file is:
    #  /sol-dist/Solaris_8/install/Solaris_8/Tools/Boot/usr/platform/sun4u/lib/fs/nfs/inetboot
    # And this must end up in the build directory as:
    #  .../inetboot.sun4u.sunos5.8
    #
    def ensureBootImageExists(self, build_dir, os_type, arch):
        if not os.path.exists(self.getTargetDir() + '/' + self.boot_file):
            (netboot_path, install) = self.db.getJSPaths(os_type)[0:2]
            (boot_server, boot_path) = install.split(':')

            #
            # This is the full path to the boot image file, on the boot server
            #
            inetboot = boot_path + '/' + netboot_path + '/usr/platform/' \
                       + arch + '/lib/fs/nfs/inetboot'
            status = Utils.scp("%s.cs.brown.edu:%s" % (boot_server,
                                                        inetboot),
                               self.bootimages[(os_type, arch)])
            status = 0
            if status:
                Utils.warn("Warning - can't copy sun boot image: scp returned %d\n" % (status))

class TftpbootLinux(Tftpboot):
    def __init__(self, db):
        Target.__init__(self, db)
        self.nidsWithSpecialConfigs = None

    def getFAIConfig(self, nid):
        if nid not in self.nidsWithSpecialConfigs:
            return globals.default_fai_config
        return self.db.getFAIConfig(nid) or globals.default_fai_config

    def warnIfNoConfigFile(self, filename, hostname):
        if not os.path.exists(self.getTargetDir() + '/' + filename):
            Utils.warn("Warning - %s's FAI config '%s' doesn't exist."\
                       % (hostname, filename))

    def createSymlink(self, nid, ip, hostname):
        fai_config = self.getFAIConfig(nid)
        self.warnIfNoConfigFile(fai_config, hostname)
        hexip = self.ip2hex(ip)
        Utils.make_link(fai_config, self.getBuildDir() + '/' + hexip)

    def build(self, build_dir):
        Utils.verbose(1, 'Linux...')

        if self.nidsWithSpecialConfigs is None:
            self.nidsWithSpecialConfigs = self.db.getFAIConfigNids()

        iter = self.db.get_nid_ipaddr_hostname('linux')
        while iter.hasNext():
            (nid, ip, hostname) = iter.next()
            self.createSymlink(nid, ip, hostname)
        self.nidsWithSpecialConfigs = None

import DNSFile

class DNS(Target):
    def __init__(self, db):
        self.toBuild = [ DNSFile.DNSForward(db) ] \
                       + [ DNSFile.DNSReverse(db, sub)
                           for sub in globals.dns_subnets ]

    def build(self):        
        self.copyFilesToBuildDir(self.makeFileList())
        for t in self.toBuild:
            t.build()

    def install(self):
        status = self.installFiles()
        if status:
            Utils.warn("Couldn't install DNS files!")
        else:
            Utils.verbose(1, "Restarting Server...")
            self.restartBind()

    def installFiles(self):
        filesToInstall = [t.getBuildFile() for t in self.toBuild]
        server = self.getDNSServer()
        if server:
            return Utils.scp(filesToInstall,
                             server + ':' +  self.toBuild[0].getTargetDir())
        else:
            return Utils.scp(filesToInstall, self.toBuild[0].getTargetDir())

    def restartBind(self):
        cmd = self.getRestartCommand()
        if globals.debug:
            Utils.verbose(1, '\n' + ' '.join(cmd[1:]) + '\n')
            return

        status = os.spawnvp(os.P_WAIT, cmd)
        if status:
            Utils.warn("Unable to restart DNS server!")

    def getRestartCommand(self):
        return [  'ssh', 'ssh', globals.dns_server, 'killall',
                  '-HUP', 'named' ]

    def getDNSServer(self):
        if globals.debug and globals.dns_server:
            return None
        return globals.dns_server
    
    def copyFilesToBuildDir(self, dbfiles):
        files = ','.join(dbfiles)
        server = self.getDNSServer()
        if server:
            status = Utils.scp("%s:%s{%s}" % ( server,
                                               self.toBuild[0].getTargetDir(),
                                               files),
                               Target.getBuildDir() )
        else:
            status = Utils.scp("%s{%s}" % ( self.toBuild[0].getTargetDir(),
                                            files),
                               Target.getBuildDir() )
        if status:
            Utils.die("Can't get DNS files from server %s" % server)
        for f in dbfiles:
            os.chmod("%s/%s" % (Target.getBuildDir(), f), 0644)

    def makeFileList(self):
        targetFiles = [ t.getTargetFile() for t in self.toBuild ]
        return [ os.path.split(t)[1] for t in targetFiles ]

