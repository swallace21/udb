#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;
use Pod::Usage;
use Data::Dumper;

use FindBin qw($RealBin);
use lib "$RealBin/../lib";
use BrownCS::UDB;
use BrownCS::UDB::Util qw(:all);

my $udb = BrownCS::UDB->new;

my $PNAME = 'cdb';
my $PVERS = '2.0';
my $VERSION  = "cdb version $PVERS\n";
my $USAGE  = "Client Database (CDB)\n\n";

# Default pathnames

my $PATH_CFFILE = '/tstaff/share/cdb/config.pl';

# Miscellaneous constants

my $MAXHOSTNAMELEN = 256;
my $MK_MODTIME = 0;
my $MK_BLDTIME = 1;
my $ADMINHOST = "adminhost";



#
# FUNCTION: modify_record
#    DESCR: Interactively modify a record
#

sub modify_record {
  my($key, $mkstate) = @_;
  my(@fields) = sort keys(%g_cdb_fields);
  my($record) = $cdb_by_hostname->{$key};
  my($mod, $value);
  my($modified) = 0;

  for(;;) {
    print "\nModifying record for host \"$key\":\n\n";

    foreach $i (0 .. $#fields) {
      printf(" [%d] %10s = %s\n", $i, $fields[$i], $record->{$fields[$i]});
    }

    for(;;) {
      printflush('STDOUT', "\nEnter the field number to modify or 'q' to quit ",
                 "[0-", $#fields, "q]: ");
      chop($mod = <STDIN>);
      last if(($mod eq 'q') ||
              (($mod =~ /^[0-9]+$/) && ($mod >= 0) && ($mod <= $#fields)));
    }

    last if($mod eq 'q');

    printflush('STDOUT', "Enter the new value for $fields[$mod]: ");
    chop($value = <STDIN>);

    if(defined($g_cdb_canons{$fields[$mod]})) {
      $value = &{ $g_cdb_canons{$fields[$mod]} }($value);
    }

    # Make the actual modification to the database hash

    $record->{$fields[$mod]} = $value;
    $modified = 1;

    # Touch each map in the make state file which depends on this field

    foreach $map (@{ $g_cdb_map_dependencies{$fields[$mod]} }) {
      touch_make_state($mkstate, $map);
    }
  }

  $modified = &confirm("Save modifications (y/n)[y]? ") if($modified);
  return $modified;
}


#
# FUNCTION: cdb_modify
#    DESCR: Modify a client record interactively or via the command-line.
#

sub cdb_modify {
  my(@args) = @_;
  my(@modfields) = ();
  my(@modvalues) = ();
  my($host, $idx, $mkstate);

  # Get the hostname interactively or from the command-line

  if(@args > 0) {
    $host = shift(@args);
  } else {
    printflush('STDOUT', "Enter the name of the host to modify: ");
    chop($host = <STDIN>);
  }
    
  # Build lists of fields to modify if there are arguments remaining

  foreach $arg (@args) {
    if(($idx = index($arg, '=')) > 0) {
      push(@modfields, substr($arg, 0, $idx));
      push(@modvalues, substr($arg, ++$idx));
    } else {
      warn "Usage: cdb modify [ hostname [ fieldname=value ... ]]\n";
      return 2;
    }
  }

  # Verify list of fields to modify

  foreach $field (@modfields) {
    die "Unknown fieldname: $field\n" if(!defined($g_cdb_fields{$field}));
  }

  # Lock the database and verify the hostname

  $mkstate = load_make_state($PATH_MKFILE);

  die "No record for \"$host\" found in database\n"
    if(!defined($cdb_by_hostname->{$host}));

  parse_ethernet_includes();
  parse_host_includes();

  # Verify command-line values or obtain values interactively

  if(@modfields > 0) {
    foreach $i (0 .. $#modfields) {

      # Canonicalize input value

      if(defined($g_cdb_canons{$modfields[$i]})) {
        $modvalues[$i] = &{ $g_cdb_canons{$modfields[$i]} }($modvalues[$i]);
      }

      # Verify input value and perform modification

      if(defined($g_cdb_verifications{$modfields[$i]})) {
        $status =
          &{ $g_cdb_verifications{$modfields[$i]} }($host, $modvalues[$i]);
        die "$PNAME: No modications saved\n" unless($status);
      }

      # Make the actual modification to the database hash

      $cdb_by_hostname->{$host}{$modfields[$i]} = "$modvalues[$i]";

      # Touch each map in the make state file which depends on this field

      foreach $map (@{ $g_cdb_map_dependencies{$modfields[$i]} }) {
        touch_make_state($mkstate, $map);
      }
    }

  } else {
    die "$PNAME: No modifications saved\n"
      unless(modify_record($host, $mkstate));
  }     

  # Write out the changes

  printflush('STDOUT', "Writing database file ... ");
  write_db($cdb_by_hostname);
  write_make_state($mkstate, $PATH_MKFILE);
  printflush('STDOUT', "done\n");
  return 0;
}

