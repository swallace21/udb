#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;
use Pod::Usage;
use Data::Dumper;

use FindBin qw($RealBin);
use lib "$RealBin/../lib";
use BrownCS::UDB;
use BrownCS::UDB::Util qw(ask ask_password confirm);

my $udb = BrownCS::UDB->new;

my $PNAME = 'cdb';
my $PVERS = '2.0';
my $VERSION  = "cdb version $PVERS\n";
my $USAGE  = "Client Database (CDB)\n\n";

# Default pathnames

my $PATH_CFFILE = '/tstaff/share/cdb/config.pl';

# Miscellaneous constants

my $MAXHOSTNAMELEN = 256;
my $MK_MODTIME = 0;
my $MK_BLDTIME = 1;
my $ADMINHOST = "adminhost";

# Declare hash of subcommands and the corresponding function

my %g_cdb_commands = (
  'insert' => {
    'fn' => \&cdb_insert,
    'desc' => ["insert a new host record"],
    'usage' => "$PNAME insert",
    'common' => 1,
  },
  'delete' => {
    'fn' => \&cdb_delete,
    'desc' => ["delete one or more host records"],
    'usage' => "$PNAME delete HOST...",
    'common' => 1,
  },
  'modify' => {
    'fn' => \&cdb_modify,
    'desc' => ["modify a host record"],
    'usage' => "$PNAME modify HOST [FIELD=VALUE]...",
    'common' => 1,
  },
);

# Declare hash of active database fields and a corresponding description

my %g_cdb_fields = (
  'hostname' => 'Canonical host name',
  'ip_addr' => 'IP address',
  'ethernet' => 'Ethernet address',
  'os_type' => 'Operating system type',
  'hw_arch' => 'Hardware architecture',
  'comment' => 'Comments',
  'contact' => 'Primary contact for this host',
  'classes' => 'Classes for unattended installation',
  'pxelink' => 'Image to use for net installs',
);

# sighandler :: void -> void
# Clean up and quit if we receive a signal.
sub sighandler {
  print "\n*** Termination signal received\n";
  $udb->finish;
  exit(0);
}

#
# FUNCTION: modify_record
#    DESCR: Interactively modify a record
#

sub modify_record {
  my($key, $mkstate) = @_;
  my(@fields) = sort keys(%g_cdb_fields);
  my($record) = $cdb_by_hostname->{$key};
  my($mod, $value);
  my($modified) = 0;

  for(;;) {
    print "\nModifying record for host \"$key\":\n\n";

    foreach $i (0 .. $#fields) {
      printf(" [%d] %10s = %s\n", $i, $fields[$i], $record->{$fields[$i]});
    }

    for(;;) {
      printflush('STDOUT', "\nEnter the field number to modify or 'q' to quit ",
                 "[0-", $#fields, "q]: ");
      chop($mod = <STDIN>);
      last if(($mod eq 'q') ||
              (($mod =~ /^[0-9]+$/) && ($mod >= 0) && ($mod <= $#fields)));
    }

    last if($mod eq 'q');

    printflush('STDOUT', "Enter the new value for $fields[$mod]: ");
    chop($value = <STDIN>);

    if(defined($g_cdb_canons{$fields[$mod]})) {
      $value = &{ $g_cdb_canons{$fields[$mod]} }($value);
    }

    # Make the actual modification to the database hash

    $record->{$fields[$mod]} = $value;
    $modified = 1;

    # Touch each map in the make state file which depends on this field

    foreach $map (@{ $g_cdb_map_dependencies{$fields[$mod]} }) {
      touch_make_state($mkstate, $map);
    }
  }

  $modified = &confirm("Save modifications (y/n)[y]? ") if($modified);
  return $modified;
}

#
# FUNCTION: cdb_delete
#    DESCR: Delete the specified records from the database.
#

sub cdb_delete {
  my(@args) = @_;
  my($mkstate);

  if(@args == 0) {
    warn "Usage: cdb delete [hostname ...]\n";
    return 2;
  }

  foreach $host (@args) {
    if(defined($cdb_by_hostname->{$host})) {
      delete $cdb_by_hostname->{$host};
      $g_modified = 1;
    } else {
      warn "$PNAME: No record exists for host \"$host\"\n";
    }
  }

  if($g_modified) {
    printflush('STDOUT', "Writing database file ... ") if($opt_v);
    write_db($cdb_by_hostname);
    printflush('STDOUT', "done\n") if($opt_v);

    $mkstate = load_make_state($PATH_MKFILE);
    foreach $map (keys(%g_cdb_maps)) { touch_make_state($mkstate, $map); }
    write_make_state($mkstate, $PATH_MKFILE);
  }

  return 0;
}

#
# FUNCTION: cdb_modify
#    DESCR: Modify a client record interactively or via the command-line.
#

sub cdb_modify {
  my(@args) = @_;
  my(@modfields) = ();
  my(@modvalues) = ();
  my($host, $idx, $mkstate);

  # Get the hostname interactively or from the command-line

  if(@args > 0) {
    $host = shift(@args);
  } else {
    printflush('STDOUT', "Enter the name of the host to modify: ");
    chop($host = <STDIN>);
  }
    
  # Build lists of fields to modify if there are arguments remaining

  foreach $arg (@args) {
    if(($idx = index($arg, '=')) > 0) {
      push(@modfields, substr($arg, 0, $idx));
      push(@modvalues, substr($arg, ++$idx));
    } else {
      warn "Usage: cdb modify [ hostname [ fieldname=value ... ]]\n";
      return 2;
    }
  }

  # Verify list of fields to modify

  foreach $field (@modfields) {
    die "Unknown fieldname: $field\n" if(!defined($g_cdb_fields{$field}));
  }

  # Lock the database and verify the hostname

  $mkstate = load_make_state($PATH_MKFILE);

  die "No record for \"$host\" found in database\n"
    if(!defined($cdb_by_hostname->{$host}));

  parse_ethernet_includes();
  parse_host_includes();

  # Verify command-line values or obtain values interactively

  if(@modfields > 0) {
    foreach $i (0 .. $#modfields) {

      # Canonicalize input value

      if(defined($g_cdb_canons{$modfields[$i]})) {
        $modvalues[$i] = &{ $g_cdb_canons{$modfields[$i]} }($modvalues[$i]);
      }

      # Verify input value and perform modification

      if(defined($g_cdb_verifications{$modfields[$i]})) {
        $status =
          &{ $g_cdb_verifications{$modfields[$i]} }($host, $modvalues[$i]);
        die "$PNAME: No modications saved\n" unless($status);
      }

      # Make the actual modification to the database hash

      $cdb_by_hostname->{$host}{$modfields[$i]} = "$modvalues[$i]";

      # Touch each map in the make state file which depends on this field

      foreach $map (@{ $g_cdb_map_dependencies{$modfields[$i]} }) {
        touch_make_state($mkstate, $map);
      }
    }

  } else {
    die "$PNAME: No modifications saved\n"
      unless(modify_record($host, $mkstate));
  }     

  # Write out the changes

  printflush('STDOUT', "Writing database file ... ");
  write_db($cdb_by_hostname);
  write_make_state($mkstate, $PATH_MKFILE);
  printflush('STDOUT', "done\n");
  return 0;
}

# print out extended help

sub cdb_help {

  if (@_ == 1) {
    command_help($ARGV[0]);
  } else {
    print $USAGE;
    print "options:\n\n";
    print "  -V Display version info\n";
    print "  -v Set verbose mode\n\n";
    print "  -u Specify username (default is current user)\n\n";
    print "all commands:\n\n";
    foreach $k (sort(keys(%g_cdb_commands))) {
      print "  $k\t" , $g_cdb_commands{$k}{'desc'}[0] , "\n";
    }
    print "\n";
  }
  return 0;
}

# Parse the command-line, load the database file, and execute a command

my $help = 0;
my $verbose = 0;
my $version = 0;
my $username = $ENV{'USER'};

GetOptions ('help|h|?' => \$help, 
            'v|verbose' => \$verbose,
            'version' => \$version,
            'u' => \$username) or usage(2);
usage(1) if $help;

if ($version) {
  print $VERSION;
  exit(0);
}

if (@ARGV == 0) {
  usage(0);
}

# Load the configuration file and perform some checking on it

die "$PNAME: $PATH_CFFILE: $!\n" unless(-f("$PATH_CFFILE"));
eval('require("$PATH_CFFILE");');
die "$PNAME: Failed to load $PATH_CFFILE: $@\n" if($@);

# Install signal handlers

$SIG{'INT'} = \&sighandler;
$SIG{'HUP'} = \&sighandler;
$SIG{'TERM'} = \&sighandler;

# Execute the appropriate subcommand

if(defined($g_cdb_commands{$ARGV[0]})) {
  $g_cmdname = shift(@ARGV);
  my $password = &ask_password;
  $udb->start($username, $password);
  $g_status = &{ $g_cdb_commands{$g_cmdname}{'fn'} }(@ARGV);
  $udb->finish;
  exit($g_status);
}

die "$PNAME: Invalid command -- $ARGV[0]\n$USAGE";

__END__

=head1 NAME

cdb - Client database front-end

=head1 SYNOPSIS

cdb [-hv] command [args ...]

=head1 DESCRIPTION

The B<cdb> database front-end program reads in the latest copy of the database
and a configuration file describing various parameters for the domain, and then
allows the user to add, remove, or modify records, or to perform simple
queries.  Using the front-end also reduces errors: all names and addresses are
automatically converted to standard formats, and the database automatically
checks for conflicts, preventing duplicate hostnames or addresses from being
entered into the database.  If changes have been made, the B<cdb make> command
is used to rebuilt all system configuration files which will be affected by the
changes.  The database modifications may be performed safely by any user with
appropriate privileges from any machine.  The rebuild command must be issued as
root from the NIS master machine.

Each client stored in the database must belong to a designated primary
netgroup, which must be described in the database configuration file, and may
also belong to one or more supplementary netgroups.  Based on the client's
primary group, the information for a record will be output to one or more
system-wide maps when they are generated from the database.  This allows the
administrator to configure, for example, a primary group for which
B<hosts.equiv(4)> entries will be generated, and another primary group for
which they will not.  All primary groups and the maps they will produce are
defined in the database configuration file.

Each database record consists of a set of fields which are stored as ASCII
text strings.  Certain fields are mandatory and must contain legal values.
Other fields are optional, and may be left blank.  The front-end software
enforces these policies so that the user cannot insert an invalid record.
The fields associated with each record are:

=over

=item I<"hostname">

The client's unqualified Internet hostname.  This field is guaranteed to be
unique in the database.

=item I<"aliases">

A comma-separated list of Internet host aliases.  Each alias is guaranteed to
be unique to both the aliases and hostname fields across all database records.

=item I<"prim_grp">

The client's primary netgroup.  This field is verified to be a valid primary
group in the database configuration file.

=item I<"supp_grps">

A comma-separated list of supplementary netgroups.  This field may be
left blank, or set to a list of arbitrary netgroup names, which must not
be the names of any known primary group.  When the B<netgroup>(4) map is
generated, entries for all known supplementary netgroup names will be
created.

=item I<"ip_addr">

The client's IP address in dotted-decimal format.  This field is always required
and it guaranteed to be unique across all database records.

=item I<"ethernet">

The client's 48-bit ethernet address.  This field is guaranteed to be
unique across all database records.  The field may be left blank, unless
the record's primary group is used to generate the B<ethers>(4) map, in
which case it is required.

=item I<"hw_arch">

The client's hardware architecture.  This field is typically set to the
output of the B<uname>(1) B<-m> command run on the client machine.  This
field may be left blank, unless the record's primary group is used to
generate a B<tftp>(1) network boot image, in which case it is required.

=item I<"os_type">

The client's operating system type string.  This field may be left
blank, unless the client's primary group is used to generate the
B<bootparams>(4) map, it which case it is required and must be set to
one of the valid operating system types defined in the database
configuration file.

=item I<"mxhost">

The fully-qualified Internet name of another host which exchanges electronic
mail for the client.  If not blank, this field is used to generate MX records
in the DNS zone files created by the front-end.

=item I<"port">

The client's network port.  This field is entirely optional, and is meant to
be used to record the network jack number to which the client is connected.

=item I<"comment">

An arbitrary comment describing the host.  This field may be left blank.

=item I<"status">

The current machine status, selected from the legal status strings set
in the configuration file.

=back

=head1 AUTHORS

=item =item =cut

