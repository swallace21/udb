#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;
use Pod::Usage;
use Data::Dumper;

use FindBin qw($RealBin);
use lib "$RealBin/../lib";
use BrownCS::UDB;
use BrownCS::UDB::Util qw(ask ask_password confirm);

my $udb = BrownCS::UDB->new;

my $PNAME = 'cdb';
my $PVERS = '2.0';
my $VERSION  = "cdb version $PVERS\n";
my $USAGE  = "Client Database (CDB)\n\n";

# Default pathnames

my $PATH_CFFILE = '/tstaff/share/cdb/config.pl';

# Miscellaneous constants

my $MAXHOSTNAMELEN = 256;
my $MK_MODTIME = 0;
my $MK_BLDTIME = 1;
my $ADMINHOST = "adminhost";

# Declare hash of subcommands and the corresponding function

my %g_cdb_commands = (
  'insert' => {
    'fn' => \&cdb_insert,
    'desc' => ["insert a new host record"],
    'usage' => "$PNAME insert",
    'common' => 1,
  },
  'delete' => {
    'fn' => \&cdb_delete,
    'desc' => ["delete one or more host records"],
    'usage' => "$PNAME delete HOST...",
    'common' => 1,
  },
  'modify' => {
    'fn' => \&cdb_modify,
    'desc' => ["modify a host record"],
    'usage' => "$PNAME modify HOST [FIELD=VALUE]...",
    'common' => 1,
  },
);

# Declare hash of active database fields and a corresponding description

my %g_cdb_fields = (
  'hostname' => 'Canonical host name',
  'ip_addr' => 'IP address',
  'ethernet' => 'Ethernet address',
  'os_type' => 'Operating system type',
  'hw_arch' => 'Hardware architecture',
  'comment' => 'Comments',
  'contact' => 'Primary contact for this host',
  'classes' => 'Classes for unattended installation',
  'pxelink' => 'Image to use for net installs',
);

# sighandler :: void -> void
# Clean up and quit if we receive a signal.
sub sighandler {
  print "\n*** Termination signal received\n";
  $udb->finish;
  exit(0);
}

#
# FUNCTION: modify_record
#    DESCR: Interactively modify a record
#

sub modify_record {
  my($key, $mkstate) = @_;
  my(@fields) = sort keys(%g_cdb_fields);
  my($record) = $cdb_by_hostname->{$key};
  my($mod, $value);
  my($modified) = 0;

  for(;;) {
    print "\nModifying record for host \"$key\":\n\n";

    foreach $i (0 .. $#fields) {
      printf(" [%d] %10s = %s\n", $i, $fields[$i], $record->{$fields[$i]});
    }

    for(;;) {
      printflush('STDOUT', "\nEnter the field number to modify or 'q' to quit ",
                 "[0-", $#fields, "q]: ");
      chop($mod = <STDIN>);
      last if(($mod eq 'q') ||
              (($mod =~ /^[0-9]+$/) && ($mod >= 0) && ($mod <= $#fields)));
    }

    last if($mod eq 'q');

    printflush('STDOUT', "Enter the new value for $fields[$mod]: ");
    chop($value = <STDIN>);

    if(defined($g_cdb_canons{$fields[$mod]})) {
      $value = &{ $g_cdb_canons{$fields[$mod]} }($value);
    }

    # Make the actual modification to the database hash

    $record->{$fields[$mod]} = $value;
    $modified = 1;

    # Touch each map in the make state file which depends on this field

    foreach $map (@{ $g_cdb_map_dependencies{$fields[$mod]} }) {
      touch_make_state($mkstate, $map);
    }
  }

  $modified = &confirm("Save modifications (y/n)[y]? ") if($modified);
  return $modified;
}

#
# FUNCTION: cdb_delete
#    DESCR: Delete the specified records from the database.
#

sub cdb_delete {
  my(@args) = @_;
  my($mkstate);

  if(@args == 0) {
    warn "Usage: cdb delete [hostname ...]\n";
    return 2;
  }

  foreach $host (@args) {
    if(defined($cdb_by_hostname->{$host})) {
      delete $cdb_by_hostname->{$host};
      $g_modified = 1;
    } else {
      warn "$PNAME: No record exists for host \"$host\"\n";
    }
  }

  if($g_modified) {
    printflush('STDOUT', "Writing database file ... ") if($opt_v);
    write_db($cdb_by_hostname);
    printflush('STDOUT', "done\n") if($opt_v);

    $mkstate = load_make_state($PATH_MKFILE);
    foreach $map (keys(%g_cdb_maps)) { touch_make_state($mkstate, $map); }
    write_make_state($mkstate, $PATH_MKFILE);
  }

  return 0;
}

#
# FUNCTION: cdb_modify
#    DESCR: Modify a client record interactively or via the command-line.
#

sub cdb_modify {
  my(@args) = @_;
  my(@modfields) = ();
  my(@modvalues) = ();
  my($host, $idx, $mkstate);

  # Get the hostname interactively or from the command-line

  if(@args > 0) {
    $host = shift(@args);
  } else {
    printflush('STDOUT', "Enter the name of the host to modify: ");
    chop($host = <STDIN>);
  }
    
  # Build lists of fields to modify if there are arguments remaining

  foreach $arg (@args) {
    if(($idx = index($arg, '=')) > 0) {
      push(@modfields, substr($arg, 0, $idx));
      push(@modvalues, substr($arg, ++$idx));
    } else {
      warn "Usage: cdb modify [ hostname [ fieldname=value ... ]]\n";
      return 2;
    }
  }

  # Verify list of fields to modify

  foreach $field (@modfields) {
    die "Unknown fieldname: $field\n" if(!defined($g_cdb_fields{$field}));
  }

  # Lock the database and verify the hostname

  $mkstate = load_make_state($PATH_MKFILE);

  die "No record for \"$host\" found in database\n"
    if(!defined($cdb_by_hostname->{$host}));

  parse_ethernet_includes();
  parse_host_includes();

  # Verify command-line values or obtain values interactively

  if(@modfields > 0) {
    foreach $i (0 .. $#modfields) {

      # Canonicalize input value

      if(defined($g_cdb_canons{$modfields[$i]})) {
        $modvalues[$i] = &{ $g_cdb_canons{$modfields[$i]} }($modvalues[$i]);
      }

      # Verify input value and perform modification

      if(defined($g_cdb_verifications{$modfields[$i]})) {
        $status =
          &{ $g_cdb_verifications{$modfields[$i]} }($host, $modvalues[$i]);
        die "$PNAME: No modications saved\n" unless($status);
      }

      # Make the actual modification to the database hash

      $cdb_by_hostname->{$host}{$modfields[$i]} = "$modvalues[$i]";

      # Touch each map in the make state file which depends on this field

      foreach $map (@{ $g_cdb_map_dependencies{$modfields[$i]} }) {
        touch_make_state($mkstate, $map);
      }
    }

  } else {
    die "$PNAME: No modifications saved\n"
      unless(modify_record($host, $mkstate));
  }     

  # Write out the changes

  printflush('STDOUT', "Writing database file ... ");
  write_db($cdb_by_hostname);
  write_make_state($mkstate, $PATH_MKFILE);
  printflush('STDOUT', "done\n");
  return 0;
}

# print out extended help

sub cdb_help {

  if (@_ == 1) {
    command_help($ARGV[0]);
  } else {
    print $USAGE;
    print "options:\n\n";
    print "  -V Display version info\n";
    print "  -v Set verbose mode\n\n";
    print "  -u Specify username (default is current user)\n\n";
    print "all commands:\n\n";
    foreach $k (sort(keys(%g_cdb_commands))) {
      print "  $k\t" , $g_cdb_commands{$k}{'desc'}[0] , "\n";
    }
    print "\n";
  }
  return 0;
}

# Parse the command-line, load the database file, and execute a command

my $help = 0;
my $verbose = 0;
my $version = 0;
my $username = $ENV{'USER'};

GetOptions ('help|h|?' => \$help, 
            'v|verbose' => \$verbose,
            'version' => \$version,
            'u' => \$username) or usage(2);
usage(1) if $help;

if ($version) {
  print $VERSION;
  exit(0);
}

if (@ARGV == 0) {
  usage(0);
}

# Load the configuration file and perform some checking on it

die "$PNAME: $PATH_CFFILE: $!\n" unless(-f("$PATH_CFFILE"));
eval('require("$PATH_CFFILE");');
die "$PNAME: Failed to load $PATH_CFFILE: $@\n" if($@);

# Install signal handlers

$SIG{'INT'} = \&sighandler;
$SIG{'HUP'} = \&sighandler;
$SIG{'TERM'} = \&sighandler;

# Execute the appropriate subcommand

if(defined($g_cdb_commands{$ARGV[0]})) {
  $g_cmdname = shift(@ARGV);
  my $password = &ask_password;
  $udb->start($username, $password);
  $g_status = &{ $g_cdb_commands{$g_cmdname}{'fn'} }(@ARGV);
  $udb->finish;
  exit($g_status);
}

die "$PNAME: Invalid command -- $ARGV[0]\n$USAGE";

