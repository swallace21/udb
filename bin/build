#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;
use Pod::Usage;
use Data::Dumper;
use NetAddr::IP qw(Coalesce);
use List::MoreUtils qw(uniq);

use FindBin qw($RealBin);
use lib "$RealBin/../lib";
use BrownCS::UDB;
use BrownCS::UDB::Util qw(ask_password get_date fmt_time ipv4_n2x);

# Print a simple help message.
sub usage {
  my ($exit_status) = @_;
  pod2usage({ -exitval => $exit_status, -verbose => 1});
}

my $help = 0;
my $username = $ENV{'USER'};
my $udb = BrownCS::UDB->new;
my $dry_run = 1;
my $verbose = 0;

GetOptions ('help|h|?' => \$help, 
            'n|dryrun' => \$dry_run,
            'v|verbose' => \$verbose,
            'u' => \$username) or usage(2);
usage(1) if $help;

if (@ARGV > 0) {
  usage(2);
}

my $password = &ask_password;

$udb->start($username, $password);

&build_netgroup;
&build_dhcp;
&build_nagios_hosts;
&build_nagios_services;
&build_wpkg_hosts;
&build_dns;
&build_ypmake;

END {
  $udb->finish;
}

sub maybe_system {
  if ($dry_run) {
    print "DEBUG: @_\n";
  } else {
    system(@_);
  }
}

sub maybe_rename {
  my ($old, $new) = @_;
  if ($dry_run) {
    print "DEBUG: rename $old to $new\n";
  } else {
    die "$0: ERROR: Failed to rename $new: $!\n" if(!rename("$old", "$new"));
  }
}

sub add_to_group {
  my ($netgroups, $grp, $host) = @_;

  if(defined($netgroups->{$grp})) {
    $netgroups->{$grp} .= " (${host},,)";
  } else {
    $netgroups->{$grp} = "(${host},,)";
  }

}

#
# FUNCTION: build_netgroup
#    DESCR: Generate the netgroup database
#

sub build_netgroup {
  my(%netgroups) = ();
  my $host_classes = $udb->get_host_class_map;

  my $sth = $udb->prepare("select e.name, c.os, e.managed_by from equipment e, computers c where c.name = e.name");
  $sth->execute();
  my $array_ref = $sth->fetchall_arrayref({});

  foreach my $host (@{$array_ref}) {

    my $hostname = $host->{name};
    my $manager = $host->{managed_by};
    my $os = $host->{os};

    if (($manager eq 'tstaff') and (defined $os) and ($os =~ /^(?:linux|linux-server|solaris)$/)) {
      add_to_group(\%netgroups, "trusted", $hostname);
    }

    my $classes_ref = $host_classes->{$hostname};
    next unless defined $classes_ref;
    my @classes = @{$classes_ref};

    for (@classes) {

      if (/^camera$/) {
        add_to_group(\%netgroups, "camera", $hostname);
      } elsif (/^cgc$/) {
        add_to_group(\%netgroups, "cgc", $hostname);
      } elsif (/^graphics$/) {
        add_to_group(\%netgroups, "graphics", $hostname);
      } elsif (/^fun$/) {
        add_to_group(\%netgroups, "ugrad", $hostname);
      } elsif (/^ssh\.forward$/) {
        add_to_group(\%netgroups, "sunlab", $hostname);
      } elsif (/^tstaff-netgroup$/) {
        add_to_group(\%netgroups, "tstaff", $hostname);
      } elsif (/^thermo$/) {
        add_to_group(\%netgroups, "thermo", $hostname);
      } elsif (/^liebert$/) {
        add_to_group(\%netgroups, "liebert", $hostname);
      } elsif (/^server$/) {
        add_to_group(\%netgroups, "server", $hostname);
      }
    }
  }

  foreach my $grp (sort(keys(%netgroups))) {
    my $val = $netgroups{$grp};
    maybe_system("/tstaff/bin/ldap-netgroup -e '$val' set $grp 2>/dev/null >/dev/null");
  }

}

sub build_dhcp {

  my @CDB_DHCP_SERVERS = qw(payday snickers);

  my $include = '/u/system/include/cdb_dhcp.in';
  my ($sth, $array_ref);
  my $file;

  if ($dry_run) {
    $file = '/tmp/dhcpd.conf';
  } else {
    $file = '/maytag/sys0/dhcp/dhcpd.conf';
  }

  my $PATH_TMPFILE = $file . '.tmp';

  open(DHCP, ">$PATH_TMPFILE") || die "$0: ERROR: Failed to open $PATH_TMPFILE: $!\n";

  print DHCP "#\n#  FILE: $file\n",
  "# DESCR: DHCP config generated by udb\n",
  "#  DATE: ", get_date(), "\n#\n\n";

  if(-s ("$include")) {
    open(INCLUDE, "<$include") || die "$0: ERROR: Failed to open include $include: $!\n";

    my @inctext = <INCLUDE>;
    print DHCP @inctext;
    close(INCLUDE);
  }

  #
  # PXE section
  #

  print DHCP "#\n";
  print DHCP "# PXElinux Clients\n";
  print DHCP "#\n";

  print DHCP "group {\n";
  print DHCP "    use-host-decl-names on;\n";
  print DHCP "    next-server pxe.cs.brown.edu;\n";
  print DHCP "    filename \"pxelinux.0\"\;\n\n";

  my $tftpboot_path = "/tftpboot/pxelinux.cfg";

  $sth = $udb->prepare(<<SQL
select
  ni.ethernet,
  na.ipaddr,
  c.hw_arch,
  c.os,
  c.pxelink,
  na.dns_name,
  na.domain
from
  net_addresses na,
  net_interfaces ni,
  net_addresses_net_interfaces nani,
  computers c,
  os_types o
where
  ni.equip_name = c.name and
  nani.net_addresses_id = na.id and
  nani.net_interfaces_id = ni.id and
  ni.primary_address = na.id and
  ni.ethernet is not null and
  na.ipaddr is not null and
  na.enabled = true and
  c.os = o.name and
  o.pxe_boot = true
SQL
  );

  $sth->execute();
  $array_ref = $sth->fetchall_arrayref({});

  foreach my $pxe_host (@{$array_ref}) {
    my $hostname = $pxe_host->{dns_name};
    if ($pxe_host->{domain} ne 'cs.brown.edu') {
      $hostname .= $pxe_host->{domain};
    }
    my $ip_addr = $pxe_host->{ipaddr};
    my $ethernet = $pxe_host->{ethernet};
    my $os = $pxe_host->{os};
    my $hw_arch = $pxe_host->{hw_arch};

    # write the dhcpd.conf entry
    print DHCP "    host $hostname {\n";
    print DHCP "        hardware ethernet $ethernet;\n";
    print DHCP "        fixed-address $hostname;\n";
    print DHCP "    }\n";

    # set up the pxelink
    my $bootimage;

    if (defined $pxe_host->{pxelink}) {
      $bootimage = $pxe_host->{pxelink};
    } elsif ($pxe_host->{os} eq 'linux') {
      $bootimage = ("fai-workstation-" . $pxe_host->{hw_arch});
    } elsif ($pxe_host->{os} eq 'linux-server') {
      $bootimage = ("fai-server-" . $pxe_host->{hw_arch});
    } else {
      next;
    }
      
    my $hex_ip = ipv4_n2x($ip_addr);

    if($dry_run) {
      print "DEBUG: $hex_ip -> $bootimage\n";
    } else {
      unlink("$tftpboot_path/$hex_ip");
      symlink("$bootimage", "$tftpboot_path/$hex_ip") ||
        warn "Failed to create link $hex_ip: $!\n";
    }

  }

  print DHCP "}\n\n";

  #
  # non-PXE static section
  #

  print DHCP "#\n";
  print DHCP "# Other Static DHCP Clients\n";
  print DHCP "#\n";

  print DHCP "group {\n";
  print DHCP "    use-host-decl-names on;\n";

  $sth = $udb->prepare(<<SQL
select
  ni.ethernet,
  na.ipaddr,
  c.hw_arch,
  c.os,
  c.pxelink,
  na.dns_name,
  na.domain
from
  net_addresses na,
  net_interfaces ni,
  net_addresses_net_interfaces nani,
  computers c,
  os_types o
where
  ni.equip_name = c.name and
  nani.net_addresses_id = na.id and
  nani.net_interfaces_id = ni.id and
  ni.primary_address = na.id and
  ni.ethernet is not null and
  na.ipaddr is not null and
  na.enabled = true and
  c.os = o.name and
  o.pxe_boot = false
SQL
  );

  $sth->execute();
  $array_ref = $sth->fetchall_arrayref({});

  foreach my $static_host (@{$array_ref}) {
    my $hostname = $static_host->{dns_name};
    if ($static_host->{domain} ne 'cs.brown.edu') {
      $hostname .= $static_host->{domain};
    }
    my $ip_addr = $static_host->{ipaddr};
    my $ethernet = $static_host->{ethernet};
    my $os = $static_host->{os};
    my $hw_arch = $static_host->{hw_arch};

    # write the dhcpd.conf entry
    print DHCP "    host $hostname {\n";
    print DHCP "        hardware ethernet $ethernet;\n";
    print DHCP "        fixed-address $hostname;\n";
    print DHCP "    }\n";

  }

  print DHCP "}\n\n";

  #
  # dynamic section
  #

  print DHCP "#\n";
  print DHCP "# Dynamic DHCP Clients\n";
  print DHCP "#\n";

  print DHCP "group {\n";
  print DHCP "    use-host-decl-names on;\n";

  $sth = $udb->prepare(<<SQL
select
  ni.ethernet,
  na.ipaddr,
  c.hw_arch,
  c.os,
  c.pxelink,
  na.dns_name,
  na.domain
from
  net_addresses na,
  net_interfaces ni,
  net_addresses_net_interfaces nani,
  computers c,
  os_types o,
  net_zones nz
where
  ni.equip_name = c.name and
  nani.net_addresses_id = na.id and
  nani.net_interfaces_id = ni.id and
  ni.primary_address = na.id and
  ni.ethernet is not null and
  na.ipaddr is null and
  na.enabled = true and
  nz.name = na.zone and
  c.os = o.name and
  nz.dynamic_dhcp = true
SQL
  );

  $sth->execute();
  $array_ref = $sth->fetchall_arrayref({});

  foreach my $dynamic_host (@{$array_ref}) {
    my $hostname = $dynamic_host->{dns_name};
    if ($dynamic_host->{domain} ne 'cs.brown.edu') {
      $hostname .= $dynamic_host->{domain};
    }
    my $ip_addr = $dynamic_host->{ipaddr};
    my $ethernet = $dynamic_host->{ethernet};
    my $os = $dynamic_host->{os};
    my $hw_arch = $dynamic_host->{hw_arch};

    # write the dhcpd.conf entry
    print DHCP "    host $hostname {\n";
    print DHCP "        hardware ethernet $ethernet;\n";
    print DHCP "    }\n";

  }

  print DHCP "}\n";

  print DHCP "\n# EOF\n";
  close(DHCP);

  maybe_rename($PATH_TMPFILE, $file);

  # send new config file to each server
  foreach my $host (@CDB_DHCP_SERVERS) {
    maybe_system('scp', '-pq', $file, "$host:/etc");
    if ( $? != 0 ) {
      warn "$0: ERROR: Failed to copy DNS files to $host\n";
    }
  }

  maybe_system('ssh', '-x', 'dhcp', '/etc/init.d/dhcp restart');
}

# 
# FUNCTION: build_nagios_hosts
#    DESCR: Generate the nagios hosts.cfg file
#

sub build_nagios_hosts {

  my $file = $dry_run ? '/tmp/hosts.cfg' : '/maytag/sys0/Linux/files/add/group.debian.server.nagios3/etc/nagios3/conf.d/hosts.cfg';
  my $PATH_TMPFILE = $file . '.tmp';
  my $include = '/u/system/include/cdb_nagios_hosts.in';
  my $date = get_date();

  open(OUT, ">$PATH_TMPFILE") || die "$0: ERROR: Failed to open $PATH_TMPFILE: $!\n";
  print OUT <<EOF
#
#  FILE: $file
# DESCR: nagios hosts.cfg generated by udb
#  DATE: $date
#

EOF
  ;

  if(-s ("$include")) {
    open(INCLUDE, "<$include") || die "$0: ERROR: Failed to open include $include: $!\n";
    my @inctext = <INCLUDE>;
    print OUT @inctext;
    close(INCLUDE);
  }

  my $sth = $udb->prepare("select na.ipaddr, na.dns_name, na.domain from net_addresses na where na.monitored = true and na.enabled = true");
  $sth->execute();
  my $array_ref = $sth->fetchall_arrayref({});

  foreach my $addr (@{$array_ref}) {
    my $hostname = $addr->{dns_name};
    if ($addr->{domain} ne 'cs.brown.edu') {
      $hostname .= $addr->{domain};
    }
    my $ip_addr = $addr->{ipaddr};

    print OUT "define host{\n";
    print OUT "\tuse\t\t\thost_template\n";
    print OUT "\thost_name\t\t$hostname\n";
    print OUT "\taddress\t\t\t$ip_addr\n";
    print OUT "}\n\n";

    print OUT "define service{\n";
    print OUT "\tuse\t\t\tping_template\n";
    print OUT "\thost_name\t\t$hostname\n";
    print OUT "}\n\n";    
  }

  print OUT "# EOF\n";
  close(OUT);

  maybe_rename($PATH_TMPFILE, $file);

  # send new config file to each server
  maybe_system('scp', '-pq', $file, "storm:/etc/nagios3/conf.d/");
  if ( $? != 0 ) {
    warn "$0: ERROR: Failed to copy nagios files to storm\n";
  }

  maybe_system('ssh', '-x', 'storm', '/etc/init.d/nagios3 restart');

}

# 
# FUNCTION: build_nagios_services
#    DESCR: Generate the nagios services.cfg file
#

sub build_nagios_services {

  my $file = $dry_run ? '/tmp/services.cfg' : '/maytag/sys0/Linux/files/add/group.debian.server.nagios3/etc/nagios3/conf.d/services.cfg';
  my $PATH_TMPFILE = $file . '.tmp';
  my $include = '/u/system/include/cdb_nagios_services.in';
  my $date = get_date();

  open(OUT, ">$PATH_TMPFILE") || die "$0: ERROR: Failed to open $PATH_TMPFILE: $!\n";
  print OUT <<EOF
#
#  FILE: $file
# DESCR: nagios services.cfg generated by udb
#  DATE: $date
#

EOF
  ;

  if(-s ("$include")) {
    open(INCLUDE, "<$include") || die "$0: ERROR: Failed to open include $include: $!\n";
    my @inctext = <INCLUDE>;
    print OUT @inctext;
    close(INCLUDE);
  }

  my ($sth, $array_ref);

  $sth = $udb->prepare(<<SQL
select
  na.ipaddr,
  na.dns_name,
  na.domain,
  ns.service
from
  net_addresses na,
  net_services ns,
  net_addresses_net_services nans
where
  nans.net_addresses_id = na.id and
  nans.net_services_id = ns.service and
  na.monitored = true and
  na.enabled = true
SQL
  );

  $sth->execute();
  $array_ref = $sth->fetchall_arrayref({});

  foreach my $addr_svc (@{$array_ref}) {
    my $hostname = $addr_svc->{dns_name};
    if ($addr_svc->{domain} ne 'cs.brown.edu') {
      $hostname .= $addr_svc->{domain};
    }
    my $ip_addr = $addr_svc->{ipaddr};

    my $service = $addr_svc->{service};

    for ($service) {

      if (/^printer$/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tprinter_template\n";
        print OUT "\thost_name\t\t$hostname\n";
        print OUT "}\n\n";    

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tqueuing_template\n";
        print OUT "\thost_name\t\t$hostname\n";
        print OUT "\tcheck_command\t\tcheck-queuing!$hostname\n";
        print OUT "}\n\n";

      } elsif (/^smtp$/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tsmtp_template\n";
        print OUT "\thost_name\t\t$hostname\n";
        print OUT "}\n\n";    

      } elsif (/^ftp$/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tftp_template\n";
        print OUT "\thost_name\t\t$hostname\n";
        print OUT "}\n\n";    

      } elsif (/^http$/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\thttp_template\n";
        print OUT "\thost_name\t\t$hostname\n";
        print OUT "}\n\n";    

      } elsif (/^imap$/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\timap_template\n";
        print OUT "\thost_name\t\t$hostname\n";
        print OUT "}\n\n";    

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tpop_template\n";
        print OUT "\thost_name\t\t$hostname\n";
        print OUT "}\n\n";    

      } elsif (/^dns$/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tdns_template\n";
        print OUT "\thost_name\t\t$hostname\n";
        print OUT "}\n\n";

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tdns_internal_template\n";
        print OUT "\thost_name\t\t$hostname\n";
        print OUT "}\n\n";    

      } elsif (/^dhcp$/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tdhcp_template\n";
        print OUT "\thost_name\t\t$hostname\n";
        print OUT "}\n\n";

      } elsif (/^telnet$/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\ttelnet_template\n";
        print OUT "\thost_name\t\t$hostname\n";
        print OUT "}\n\n";

      } elsif (/^liebert$/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tliebert_template\n";
        print OUT "\thost_name\t\t$hostname\n";
        print OUT "\tcontact_groups\t\tspoc_group,tstaff_group\n";
        print OUT "}\n\n";

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tliebert_alarms_template\n";
        print OUT "\thost_name\t\t$hostname\n";
        print OUT "\tcontact_groups\t\tspoc_group,tstaff_group\n";
        print OUT "}\n\n";

      } elsif (/^thermo$/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tthermo_template\n";
        print OUT "\thost_name\t\t$hostname\n";
        print OUT "\tcontact_groups\t\temergency_group,spoc_group,tstaff_group\n";
        print OUT "}\n\n";

      } elsif (/^pgsql$/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tpgsql_template\n";
        print OUT "\thost_name\t\t$hostname\n";
        print OUT "}\n\n";

      } elsif (/^netapp$/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tnetapp_template\n";
        print OUT "\thost_name\t\t$hostname\n";
        print OUT "}\n\n";

      } elsif (/^ntp$/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tntp_template\n";
        print OUT "\thost_name\t\t$hostname\n";
        print OUT "}\n\n";

      } elsif (/^ssh$/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tssh_template\n";
        print OUT "\thost_name\t\t$hostname\n";
        print OUT "}\n\n";

      } elsif (/^mailman$/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tmailman_template\n";
        print OUT "\thost_name\t\t$hostname\n";
        print OUT "}\n\n";

      } elsif (/^spamassassin$/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tspamd_template\n";
        print OUT "\thost_name\t\t$hostname\n";
        print OUT "}\n\n";

        print OUT "define service{\n";
        print OUT "\tuse\t\t\typbind_template\n";
        print OUT "\thost_name\t\t$hostname\n";
        print OUT "}\n\n";   

      } elsif (/^sge$/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tsge_template\n";
        print OUT "\thost_name\t\t$hostname\n";
        print OUT "}\n\n";

      } elsif (/^flexlm$/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tflexlm_template\n";
        print OUT "\thost_name\t\t$hostname\n";
        print OUT "}\n\n";

      } elsif (/^ldap$/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tldap_template\n";
        print OUT "\thost_name\t\t$hostname\n";
        print OUT "}\n\n";

      } elsif (/^drbd$/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tdrbd_template\n";
        print OUT "\thost_name\t\t$hostname\n";
        print OUT "}\n\n";

      } elsif (/^krb$/) {

        print OUT "define service{\n";
        print OUT "\tuse\t\t\tkrb_template\n";
        print OUT "\thost_name\t\t$hostname\n";
        print OUT "}\n\n";

      }

    }

  }

  print OUT "# EOF\n";
  close(OUT);

  maybe_rename($PATH_TMPFILE, $file);

  # send new config file to each server
  maybe_system('scp', '-pq', $file, "storm:/etc/nagios3/conf.d/");
  if ( $? != 0 ) {
    warn "$0: ERROR: Failed to copy nagios files to storm\n";
  }

  maybe_system('ssh', '-x', 'storm', '/etc/init.d/nagios3 restart');

}

# 
# FUNCTION: build_wpkg_hosts
#    DESCR: Generate the wpkg hosts.xml file
#

sub build_wpkg_hosts {

  my $file = $dry_run ? '/tmp/wpkg-hosts.xml' : '/u/system/win32/WPKG/hosts/cdb.xml';
  my $PATH_TMPFILE = $file . '.tmp';
  my $date = get_date();
  my $host_classes = $udb->get_host_class_map;

  open(OUT, ">$PATH_TMPFILE") || die "$0: ERROR: Failed to open $PATH_TMPFILE: $!\n";

  print OUT <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<!--
FILE: $file
DESCR: wpkg hosts.xml generated by udb
DATE: $date
-->

<wpkg>
EOF
  ;

  my $sth = $udb->prepare("select e.name, c.os from equipment e, computers c where c.name = e.name and e.managed_by = 'tstaff'");
  $sth->execute();
  my $array_ref = $sth->fetchall_arrayref({});

  foreach my $host (@{$array_ref}) {

    my $hostname = $host->{name};
    my $os = $host->{os};

    next unless((defined $os) and (($os eq 'winxp') or ($os eq 'vista')));

    # generate profile list

    my @wpkg_profiles = ();

    my $classes_ref = $host_classes->{$hostname};
    next unless defined $classes_ref;
    my @classes = @{$classes_ref};

    if ($os eq 'winxp') {
      push @wpkg_profiles, "winxp";
    } elsif ($os eq 'vista') {
      push @wpkg_profiles, "vista";
    }

    for (@classes) {

      if (/^desktop$/) {
        push @wpkg_profiles, "desktop";
        push @wpkg_profiles, "$os-dept";
      }

      if (/^classroom$/) {
        push @wpkg_profiles, "classroom";
      }

      if (/^maya$/) {
        push @wpkg_profiles, "maya";
      }

      if (/^tstaff$/) {
        push @wpkg_profiles, "tstaff";
      }

      if (/^afs$/) {
        push @wpkg_profiles, "afs";
      }

      if (/^fun$/) {
        push @wpkg_profiles, "fun";
      }

      if (/^research$/) {
        push @wpkg_profiles, "research";
        push @wpkg_profiles, "$os-research";
      }

      if (/^server$/) {
        push @wpkg_profiles, "server";
      }

      if (/^remote$/) {
        push @wpkg_profiles, "desktop";
        push @wpkg_profiles, "remote";
        push @wpkg_profiles, "$os-remote";
      }

      if (/^laptop$/) {
        push @wpkg_profiles, "$os-laptop";
      }

      if (/^laptop.loaner$/) {
        push @wpkg_profiles, "$os-laptop";
        push @wpkg_profiles, "loaner-laptop";
      }

      if (/^laptop.x61$/) {
        push @wpkg_profiles, "$os-laptop";
        push @wpkg_profiles, "x61";
      }

      # licensed software

      if (/^adobe-ae-pp$/) {
        push @wpkg_profiles, "adobe-ae-pp";
      }

      if (/^framemaker$/) {
        push @wpkg_profiles, "framemaker";
      }

      if (/^powerdvd$/) {
        push @wpkg_profiles, "powerdvd";
      }

    }

    next unless @wpkg_profiles;

    my $first_profile = shift(@wpkg_profiles);

    print OUT "  <host name=\"$hostname\" profile-id=\"$first_profile\">\n";
    foreach my $profile (@wpkg_profiles) {
      print OUT "    <profile id=\"$profile\" />\n";
    }
    print OUT "  </host>\n";
  }

  print OUT '</wpkg>', "\n";
  close(OUT);

  maybe_rename($PATH_TMPFILE, $file);

}

#
# FUNCTION: build_dns
#    DESCR: Creates the necessary dns-related files and reloads named
#

sub build_dns {
  my %handles = ();
  my @files = ();

  my ($sth, $array_ref);

  ## build headers for all the maps

  $sth = $udb->prepare(<<SQL
select
  nv.network
from
  net_vlans nv,
  net_zones nz
where
  nv.zone = nz.name
  and nz.routing_type != 'private'
SQL
  );
  $sth->execute();
  $array_ref = $sth->fetchall_arrayref({});

  my @spread_subnets = ();

  foreach my $subnet (@{$array_ref}) {
    push @spread_subnets, (new NetAddr::IP($subnet->{network}));
  }

  my $classC = Coalesce(24, 1, @spread_subnets);
  my $classB = Coalesce(16, 1, grep {$_->masklen < 24} @spread_subnets);
  my @subnets = uniq( @{$classC}, @{$classB} );

  my @forward_maps = qw(cs ilab);
  my @reverse_maps = map { $_->prefix } @subnets;
  my @all_maps = (@forward_maps, @reverse_maps);

  foreach my $zone (@all_maps) {
    # specify the current source files
    my $srcfile = $dry_run ? "/tmp/db.$zone" : "/var/named/src/db.$zone";
    my $srcinc = "/u/system/include/cdb_dns_$zone.in";

    my $handle;
    open($handle, ">$srcfile.tmp") || die "$0: ERROR: Failed to open $srcfile: $!\n";

    push @files, $srcfile;
    $handles{$zone} = $handle;

    print $handle "$ttl 1d\n";

    # Retrieve serial number from SOA line

    ($head, $tail) = split(/\(/, $line);
    @nums = split(/\s+/, $tail);
    shift(@nums);

    # Recreate line and print it to file  
             
    $line = $head . '( ' . (shift(@nums) + 1);
    while ($_ = shift(@nums)) {
      $line .= " $_";
    }
    print $handle "$line\n";

    if(-s ("$include")) {
      if (!open(INCLUDE, "<$include")) { 
        warn "$0: ERROR: Failed to open include $include: $!\n";
        return 0;
      }

      @inctext = <INCLUDE>;
      print $handle @inctext;
      close(INCLUDE);
    }

    build_dns_headers($srcfile, $srcinc, $handle);
  }

  exit(1);

  my($handle, $line, $spaces, $host, $cname, @nibbles, $subnet);

  ### foreach my $host (keys(%$cdb_by_hostname)) {
  ###   my($prim_grp) = $cdb_by_hostname->{$host}{'prim_grp'};

  ###   # TODO Don't add DNS entries for dynamic hosts

  ###   # only include hosts that are listed as active or monitored
  ###   my $status = $cdb_by_hostname->{$host}{'status'};
  ###   next unless ( $status eq "active" || $status eq "monitored" || $status eq "ugrad-monitored" );

  ###   # first write out to forward tables
  ###   if ("$prim_grp" eq "ilab") {
  ###     $handle = $handles{$prim_grp};
  ###   } else {
  ###     $handle = $handles{'cs'};
  ###   }

  ###   $spaces = ' ' x (21 - length($host));
  ###   $line = $host . $spaces . "IN  A     " .  
  ###     $cdb_by_hostname->{$host}{'ip_addr'};
  ###   print $handle "$line\n";

  ###   if ($cdb_by_hostname->{$host}{'aliases'} ne '') {
  ###     my @aliases = split(/,/, $cdb_by_hostname->{$host}{'aliases'});
  ###     while ($cname = pop(@aliases)) {
  ###       $spaces = ' ' x (21 - length($cname));
  ###       if ("$prim_grp" eq "ilab") {
  ###         $line = $cname . $spaces . "IN  CNAME " . "${host}.ilab.cs.brown.edu.";
  ###       } else {
  ###         $line = $cname . $spaces . "IN  CNAME " . "${host}.cs.brown.edu.";
  ###       }
  ###       print $handle "$line\n";
  ###     }
  ###   }

  ###   if ($cdb_by_hostname->{$host}{'mxhost'} ne '') {
  ###     $spaces = ' ' x (21 - length($host));
  ###     $line = $host . $spaces . "IN  MX    10 " . 
  ###       $cdb_by_hostname->{$host}{'mxhost'} . ".";
  ###     print $handle "$line\n";
  ###   }

  ###   # Then the appropriate subnet database

  ###   @nibbles = split(/\./, $cdb_by_hostname->{$host}{'ip_addr'});
  ###   if (grep /$nibbles[1]/, @cdb_classB_subnets) {
  ###     $subnet = $nibbles[1];
  ###   } elsif (grep /$nibbles[2]/, @cdb_classC_subnets) {
  ###     $subnet = $nibbles[2];
  ###   }

  ###   $line = "";
  ###   foreach (reverse(@nibbles)) {
  ###     $line .= "${_}.";
  ###   }

  ###   $spaces = ' ' x (18 - length($cdb_by_hostname->{$host}{'ip_addr'}));
  ###   if ("$prim_grp" eq "ilab") {
  ###     $line .= "IN-ADDR.ARPA." . $spaces . "IN  PTR   " .
  ###            "${host}.ilab.cs.brown.edu.";
  ###   } else {
  ###     $line .= "IN-ADDR.ARPA." . $spaces . "IN  PTR   " .
  ###            "${host}.cs.brown.edu.";
  ###   }

  ###   if (defined($handles{$subnet})) {  
  ###     $handle = $handles{$subnet};
  ###     print $handle "$line\n";
  ###   }
  ### }

  foreach my $handle (keys %handles) {
    close($handle);
  }

  foreach my $file (@files) {
    maybe_rename("$file.tmp", $file);

    # fix permissions the file
    #chown(0, (getgrnam('sys'))[2], $file) || warn "$0: WARNING: Failed to chown $file: $!\n";

    #chmod(0444, $file) || warn "$0: WARNING: Failed to chmod $file: $!\n";
  }

  my @dns_servers = qw(payday snickers);
  foreach my $host (@dns_servers) {
    maybe_system('scp', '-pq', @files, "$host:/var/cache/bind");
    if ( $? != 0 ) {
      warn "$0: ERROR: Failed to copy DNS files to $host\n";
    }

    maybe_system('ssh', '-x', $host, '/usr/sbin/rndc reload');
    if ( $? != 0 ) {
        warn "$0: ERROR: Failed to send DNS reload command to on $host\n";
    }
  }

}


sub build_ypmake {

  my $cmd;

  if($verbose) {
    $cmd = "/u/system/bin/ypmake";
  } else {
    $cmd = "/u/system/bin/ypmake >/dev/null"
  }

  maybe_system($cmd);

}

__END__

=head1 NAME

build - build system databases/config files from udb

=head1 SYNOPSIS

build [-u username]

=head1 DESCRIPTION

builds stuff

=head1 OPTIONS

=over

=item B<-h>, B<--help>

Print a help message and exit.

=item B<-u>, B<--username>=user

Logs onto the database server as the specified username, instead of as
the current user.

=item B<-n>, B<--dryrun>

Instead of modifying the system, print out a record of what would be
done. Some files are written to /tmp.

=item B<-v>, B<--verbose>

Print lots of text about what is going on.

=back

=head1 AUTHORS

Aleks Bromfield.

=head1 SEE ALSO

B<udb>

=cut

