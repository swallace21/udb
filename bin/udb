#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;
use Pod::Usage;

use FindBin qw($RealBin);
use lib "$RealBin/../lib";
use BrownCS::UDB;
use BrownCS::UDB::Util qw(ask_password);

use BrownCS::UDB::Frontend::Add qw(add);
use BrownCS::UDB::Frontend::ClassAdd qw(class_add);
use BrownCS::UDB::Frontend::ClassDel qw(class_del);
use BrownCS::UDB::Frontend::Classes qw(classes);
use BrownCS::UDB::Frontend::ClassShow qw(class_show);
use BrownCS::UDB::Frontend::ContactList qw(contact_list);
use BrownCS::UDB::Frontend::Del qw(del);
use BrownCS::UDB::Frontend::Mod qw(mod);
use BrownCS::UDB::Frontend::Show qw(show);

my %udb_commands = (
  'add' => {
    'fn' => \&add,
    'desc' => ["\t\tadd a new host"],
    'usage' => "add",
    'common' => 1,
  },
  'class-add' => {
    'fn' => \&class_add,
    'desc' => ["\tadd one or more hosts to a class"],
    'usage' => "class-add CLASS HOST...",
    'common' => 0,
  },
  'class-del' => {
    'fn' => \&class_del,
    'desc' => ["\tremove one or more hosts from a class"],
    'usage' => "class-del CLASS HOST...",
    'common' => 0,
  },
  'classes' => {
    'fn' => \&classes,
    'desc' => ["\tlist the classes to which the host belongs"],
    'usage' => "classes HOST",
    'common' => 0,
  },
  'class-show' => {
    'fn' => \&class_show,
    'desc' => ["\tlist the members of a class"],
    'usage' => "class-show CLASS",
    'common' => 0,
  },
  'contact-list' => {
    'fn' => \&contact_list,
    'desc' => ["print out a contact list for all hosts in a class"],
    'usage' => "contact-list CLASS",
    'common' => 0,
  },
  'delete' => {
    'fn' => \&del,
    'desc' => ["\tdelete a host"],
    'usage' => "delete HOST",
    'common' => 1,
  },
  'modify' => {
    'fn' => \&mod,
    'desc' => ["\tmodify a host"],
    'usage' => "modify HOST",
    'common' => 1,
  },
  'show' => {
    'fn' => \&show,
    'desc' => ["\tprint a summary of a host"],
    'usage' => "show HOST",
    'common' => 1,
  },
);

# Print a simple help message.
sub usage {
  my ($exit_status, $long) = @_;
  pod2usage({ -exitval => "NOEXIT", -verbose => 1});
  print "Commands:\n\n";
  foreach my $k (sort(keys(%udb_commands))) {
    if (not $long) {
      next if not $udb_commands{$k}{'common'};
    }
    print "    $k\t" . $udb_commands{$k}{'desc'}[0] . "\n";
  }
  print "\nSee 'udb help COMMAND' for more information on a specific command.\n";
  exit($exit_status);
}

# Print a simple help message for a specific command.
sub command_help {
  my ($cmd) = @_;
  print "Usage: udb ";
  print $udb_commands{$cmd}{"usage"} , "\n\n";
  my $lines = $udb_commands{$cmd}{"desc"};
  foreach my $line (@$lines) {
    $line =~ s/^\s+//;
    print "  \u$line.\n";
  }
  print "\n";
}

my $help = 0;
my $verbose = 0;
my $dryrun = 0;
my $username = $ENV{'USER'};

GetOptions ('help|h|?' => \$help, 
            'v|verbose' => \$verbose,
            'n|dryrun' => \$dryrun,
            'u' => \$username) or usage(1, 0);
usage(0, 0) if $help;

my $cmd = shift;

if (not defined $cmd) {
  usage(2, 0);
}

my $fn;

if ($cmd eq 'help') {
  if (@ARGV) {
    my $help_cmd = shift;
    command_help($help_cmd);
    exit(0);
  } else {
    usage(0, 1);
  }
}

if(defined($udb_commands{$cmd})) {
  $fn = $udb_commands{$cmd}{'fn'};
} else {
  usage(2);
}

my $password = &ask_password;

my $udb = BrownCS::UDB->new;
$udb->start($username, $password);

$fn->($udb, $verbose, $dryrun, @ARGV);

END {
  if (defined $udb) {
    $udb->finish;
  }
}

__END__

=head1 NAME

udb - main interface to the Universal DataBase

=head1 SYNOPSIS

udb [-v] [-n] [-u username] command [args ...]

=head1 DESCRIPTION

The B<cdb> database front-end program reads in the latest copy of the database
and a configuration file describing various parameters for the domain, and then
allows the user to add, remove, or modify records, or to perform simple
queries.  Using the front-end also reduces errors: all names and addresses are
automatically converted to standard formats, and the database automatically
checks for conflicts, preventing duplicate hostnames or addresses from being
entered into the database.  If changes have been made, the B<cdb make> command
is used to rebuilt all system configuration files which will be affected by the
changes.  The database modifications may be performed safely by any user with
appropriate privileges from any machine.  The rebuild command must be issued as
root from the NIS master machine.

Each client stored in the database must belong to a designated primary
netgroup, which must be described in the database configuration file, and may
also belong to one or more supplementary netgroups.  Based on the client's
primary group, the information for a record will be output to one or more
system-wide maps when they are generated from the database.  This allows the
administrator to configure, for example, a primary group for which
B<hosts.equiv(4)> entries will be generated, and another primary group for
which they will not.  All primary groups and the maps they will produce are
defined in the database configuration file.

Each database record consists of a set of fields which are stored as ASCII
text strings.  Certain fields are mandatory and must contain legal values.
Other fields are optional, and may be left blank.  The front-end software
enforces these policies so that the user cannot insert an invalid record.

=head1 OPTIONS

=over

=item B<-h>, B<--help>

Print a help message and exit.

=item B<-u>, B<--username>=user

Logs onto the database server as the specified username, instead of as
the current user.

=item B<-v>, B<--verbose>

Print lots of information about what udb is doing.

=item B<-n>, B<--dryrun>

Don't make any changes; just print what would be done.

=back

=head1 AUTHORS

Aleks Bromfield.

=cut

